<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>印第安老斑鸠</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wongchen.github.io/"/>
  <updated>2018-01-17T13:20:31.000Z</updated>
  <id>http://wongchen.github.io/</id>
  
  <author>
    <name>Wong Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>深度学习中动态加载样本</title>
    <link href="http://wongchen.github.io/2018/01/17/pytorch-dynamic-sampling/"/>
    <id>http://wongchen.github.io/2018/01/17/pytorch-dynamic-sampling/</id>
    <published>2018-01-17T12:48:34.000Z</published>
    <updated>2018-01-17T13:20:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在用CNN处理图像的时候,经常我们不是用一整张完整的图像去训练,而是经常会采用取一个图像块也就是patch来输入网络进行训练,构成我们的训练集样本和测试集样本.</p>
<p>一种常用的方法就是先把他们保存到本地硬盘中,然后每次训练时一张张去读取(或者将他们转换为<code>tfrecord</code>格式使用TensorFlow中的队列读取这些文件),最近在做3D图像的操作,直接对3D图像进行卷积,卷积核也是3维的,因此图像尺寸不可能取到很大,也是voxel patch.</p>
<p>但是3D数据是较大的,硬盘空间有时候没那么大,尤其是固态,因为固态下的文件读取速度要比机械盘快很多,所以能放到固态下的话是个不错的选择,但是对于这个问题来说,完全不够,只能放到机械盘下面.</p>
<p>还有一种想法就是: “把鸡蛋放到一个篮子里.🥚🥚🥚”</p>
<p>就是在训练时把所有数据一次性读取加载到内存中,然后训练的时候从这些图片中随机取样本,要求就是这些图片可以被同时读取到内存中,需要一定大小的内存,尤其是在一些用来跑程序的主机上,内存占用很低.</p>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>例如可以把要提取的patch的点以pickle文件保存为list对象,用pytorch实现为:</p>
<p>将所有的读取到图像以及要提取样本的关键点传入MyDataset类, 在<code>__getitem__</code>方法中对已有的图像进行切片就能得到需要的样本.</p>
<p>这样的好处就是节省硬盘空间,从内存获取数据速度较快.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">from torch.utils.data import Dataset</div><div class="line">import numpy as np</div><div class="line">import pickle</div><div class="line"></div><div class="line">class MyDataset(Dataset):</div><div class="line">	def __init__(self, src_img_list, std_img_list, points_pickle):	</div><div class="line">    	self.src_img_list = src_img_list</div><div class="line">        self.std_img_list = std_img_list</div><div class="line">        with open(points_pickle, &apos;rb&apos;) as f:</div><div class="line">              self.points = pickle.load(f)</div><div class="line">  </div><div class="line">    def __len__(self):</div><div class="line">        return len(self.points)</div><div class="line">  </div><div class="line">    def __getitem__(self, idx):</div><div class="line">        i, c, h, w = self.points[idx]</div><div class="line">        data = self.src_img_list[i][c-64:c+64, h-64:h+64, w-64:w+64].reshape([1, 128, , 128]).</div><div class="line">        target = self.std_img_list[i][c-64:c+64, h-64:h+64, w-64:w+64].reshape([1, , 128, 128]</div><div class="line">        return data, target</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在用CNN处理图像的时候,经常我们不是用一整张完整的图像去训练,而是经常会采用取一个图像块也就是patch来输入网络进行训练,构成我们的训练集样本和测试集样本.&lt;/p&gt;
&lt;p&gt;一种常用的方法就是先把他们保存到本地硬盘中,然后每次训练时一张张去读取(或者将他们转换为&lt;code
    
    </summary>
    
      <category term="Deep Learning" scheme="http://wongchen.github.io/categories/Deep-Learning/"/>
    
    
      <category term="pytorch" scheme="http://wongchen.github.io/tags/pytorch/"/>
    
      <category term="deep learning" scheme="http://wongchen.github.io/tags/deep-learning/"/>
    
  </entry>
  
  <entry>
    <title>安装TensorFlow1.5+cuda9.0+cudnn7.0</title>
    <link href="http://wongchen.github.io/2018/01/17/cuda9-cudnn7/"/>
    <id>http://wongchen.github.io/2018/01/17/cuda9-cudnn7/</id>
    <published>2018-01-17T12:17:11.000Z</published>
    <updated>2018-01-17T12:50:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>之前使用的一直是python2.7+TensorFlow1.1+cuda8.0+cudnn6.0,用了有一段时间了,python3是一直打算换过来的,毕竟py3比2增加了许多实用性的功能,而且py2逐渐不被许多库所支持,官方也声明在2020年放弃对py2的维护.</p>
<p>今天看到TensorFlow1.5版本的发布以及cuda9的发布想更新一波.</p>
<h2 id="py"><a href="#py" class="headerlink" title="py"></a>py</h2><p>由于目前还会短暂使用py2,所以需要在一台电脑上同时使用py2和py3.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ps -aux | grep python</div></pre></td></tr></table></figure>
<p>可以看到系统当前调用python的进程,看到python和python3都有.</p>
<p>可行的方法包括:</p>
<ol>
<li>virtualenv,不过暂时不想用这个.</li>
<li>最简单就是在用3的时候后面加3就好了, <code>python3</code>, <code>pip3</code></li>
<li>也可以去<a href="https://github.com/pyenv/pyenv" target="_blank" rel="external">pyenv</a>看看</li>
</ol>
<h2 id="CUDA-amp-CUDNN"><a href="#CUDA-amp-CUDNN" class="headerlink" title="CUDA &amp; CUDNN"></a>CUDA &amp; CUDNN</h2><p>官网下载cuda时选择9.0的版本,当前最新为9.1,刚开始安装了9.1的cuda toolkit,发现还是不支持,后来换到9.0版本就好了.</p>
<p>CUDNN也是官网下载deb包安装就可以.</p>
<p>驱动需要384以上,一个经验就是当电脑驱动出问题的时候,(经常登录界面无线循环,低分辨率等问题),最简单的解决办法就是把原来的使用linux apt安装的驱动包都卸载掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get remove nvidia*</div></pre></td></tr></table></figure>
<p>然后<a href="http://www.nvidia.com/Download/index.aspx?lang=cn" target="_blank" rel="external">官网</a>下载相应版本的driver, <code>.run</code>文件,用它来安装,一般可以解决驱动的问题.</p>
<h2 id="TensorFlow1-5"><a href="#TensorFlow1-5" class="headerlink" title="TensorFlow1.5"></a>TensorFlow1.5</h2><p>本来打算源码安装的,进行到<code>bazel build</code>这一步的时候一个跟网络和bazel有关的问题解决不了,也没必要这么装了.</p>
<p>索性还是pip:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">pip install tensorflow-gpu==1.5rc1 --user</div></pre></td></tr></table></figure>
<p>这样原来的python2也是还可以继续用的,新的python3也ok.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;之前使用的一直是python2.7+TensorFlow1.1+cuda8.0+cudnn6.0,用了有一段时间了,python3是一直打算换过来的,毕竟py3比2增加了许多实用性的功能,而且py2逐渐不被许多库所支持,官方也声明在2020年放弃对py2的维护.&lt;/p&gt;
&lt;
    
    </summary>
    
      <category term="TensorFlow" scheme="http://wongchen.github.io/categories/TensorFlow/"/>
    
    
      <category term="cuda" scheme="http://wongchen.github.io/tags/cuda/"/>
    
      <category term="TensorFlow" scheme="http://wongchen.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>summary2017</title>
    <link href="http://wongchen.github.io/2017/12/31/summary2017/"/>
    <id>http://wongchen.github.io/2017/12/31/summary2017/</id>
    <published>2017-12-31T07:26:51.000Z</published>
    <updated>2017-12-31T08:26:05.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="读书"><a href="#读书" class="headerlink" title="读书"></a>读书</h2><p>不得不说kindle真的是个好东西,现在看书除了理工科的一些书都在kindle下看,对眼睛好也方便,其他书籍公式较多或者代码较多还的在电脑上看</p>
<h3 id="文学"><a href="#文学" class="headerlink" title="文学"></a>文学</h3><ol>
<li>人类简史</li>
</ol>
<p><img src="https://img3.doubanio.com/lpic/s27814883.jpg" alt=""></p>
<p>起源是在Ted上看了一篇作者的演讲,兴起就打算看这两本书:人类简史与未来简史.结果只看了一篇,还是跳着看的,其中的观点还是很新颖的,不能同意更多.</p>
<ol>
<li>拉普拉斯的魔女</li>
</ol>
<p><img src="https://img3.doubanio.com/lpic/s29195703.jpg" alt=""></p>
<p>一直都很喜欢看东野的推理小说,之前也看过了嫌疑人, 放学后, 幻夜……白夜行看的电视剧是个遗憾,书确实太长了啊!</p>
<p>这本书在我看的时候还是很入胜的,不过更多的还是关于人性跟情感以及AI, 少了些许推理的部分,难怪知乎豆瓣评论一致不高.</p>
<ol>
<li>追风筝的人</li>
</ol>
<p><img src="https://img3.doubanio.com/lpic/s1727290.jpg" alt=""></p>
<blockquote>
<p>为你,千千万万遍~</p>
</blockquote>
<p>读完不禁感慨战争难民的不幸,美丽又残忍的故事,经典~</p>
<p>已经几乎忘记它带给我的最深的感受了,读过~</p>
<h3 id="DL-Programming"><a href="#DL-Programming" class="headerlink" title="DL/Programming"></a>DL/Programming</h3><ol>
<li>Deep Learning (50%)</li>
</ol>
<p><img src="https://img3.doubanio.com/lpic/s29133163.jpg" alt=""></p>
<p>传说中的花书,还没读完,读到后面感觉知识储备有些不足,就先暂停下来了,书涉及的范围比较广,刚开始英文一章一章读的,还是有些吃力,后来又读了一遍中文,现在还落着好几章的总结没有做~  :fire:</p>
<ol>
<li>PRML(in progress…. ) 🚲🚲</li>
</ol>
<p><img src="https://img1.doubanio.com/lpic/s4254558.jpg" alt=""></p>
<p>经典式教科书,读起来还是有点难,打算每天想起来,闲下来的时候拿起来读一读就好……慢慢啃吧☠️☠️</p>
<p>目前中英文混着读</p>
<ol>
<li>PGM (in progress)🚲🚲</li>
</ol>
<p><img src="https://img3.doubanio.com/lpic/s28057016.jpg" alt=""></p>
<p>读这本书是跟着coursera上的一个课程同步学习的,可惜还没读多少,明年继续….👊👊</p>
<ol>
<li>Cocoa Programming for OS X (5th Edition)</li>
</ol>
<p><img src="https://img3.doubanio.com/lpic/s28041282.jpg" alt=""></p>
<p>暑假放假回家呆了两周,断断续续看了那么些时间,跟着学了一些简单的操作,应该差不多读了50%吧,跟着书操作还是比较简单的,就是版本稍微有点旧了,许多操作及api需要改一下💪💪</p>
<ol>
<li>Python 源码剖析</li>
</ol>
<p><img src="https://img3.doubanio.com/lpic/s3435132.jpg" alt=""></p>
<p>我觉得这本书很棒,可以让我理解到python的内部的一些很好的设计,我没有仔细读C的部分,没必要,需要的时候会再认真读一遍.</p>
<ol>
<li>流畅的Python(90%)</li>
</ol>
<p><img src="https://img3.doubanio.com/lpic/s29434304.jpg" alt=""></p>
<p>可以说是2017年最佳Python进阶书目, 多个技术大咖强烈推荐,从我菜鸡的角度来看还是要花些时间去读的,豆瓣上那些花70小时读完的简直了,读书还要以小时来计时吗~~🙈🙈</p>
<p>明年准备都换到Python3下去工作,正式放弃Python2</p>
<blockquote>
<p>把相关的主题与java比较可以体会到更多乐趣</p>
</blockquote>
<p>可惜我还不会java</p>
<p>其他应该没了,读书工具一般就是kindle for mobi, iBook for epub, pdf expert for pdf.</p>
<h2 id="公开课"><a href="#公开课" class="headerlink" title="公开课"></a>公开课</h2><p>coursera 上看了几门</p>
<ol>
<li>第一个就是Ng的深度学习系列课程,分为五个部分,学起来还是比较简单的,但是没有仔细做记录也无所谓了.</li>
</ol>
<p><img src="https://ws3.sinaimg.cn/large/006tNc79ly1fn00pu433cj30m609u0tw.jpg" alt=""></p>
<ol>
<li>PGM/RL,CS249-112/CS231n2017</li>
</ol>
<ul>
<li>[ ] 还没学完,有点难,又堆到明年了</li>
<li>[ ] 概率图模型</li>
<li>[ ] 强化学习</li>
</ul>
<h2 id="学术"><a href="#学术" class="headerlink" title="学术"></a>学术</h2><p>读了许多论文,差不多100篇吧~,这里就不多说了</p>
<ul>
<li>[ ] 明年争取努力发篇论文</li>
</ul>
<h3 id="🔑🔗📌"><a href="#🔑🔗📌" class="headerlink" title="🔑🔗📌"></a>🔑🔗📌</h3><ul>
<li>加深了TensorFlow的学习</li>
<li>简单使用caffe, chainer和MXNet,</li>
<li>熟练pytorch</li>
<li>换了pixel手机❌📱</li>
<li>管理实验室Linux计算服务器</li>
</ul>
<h3 id="🔜🔜🔜"><a href="#🔜🔜🔜" class="headerlink" title="🔜🔜🔜"></a>🔜🔜🔜</h3><p>明年还有许多东西要做,压力更大了,加油</p>
<ul>
<li>[ ] 学习kotlin语言(Android 官方钦定)</li>
<li>[ ] 多读书,多看报,多打球</li>
<li>[ ] TensorFlow mobile</li>
<li>[ ] golang, Ruby, Haskell, Docker</li>
<li>[ ] python2 ⏩python3</li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;读书&quot;&gt;&lt;a href=&quot;#读书&quot; class=&quot;headerlink&quot; title=&quot;读书&quot;&gt;&lt;/a&gt;读书&lt;/h2&gt;&lt;p&gt;不得不说kindle真的是个好东西,现在看书除了理工科的一些书都在kindle下看,对眼睛好也方便,其他书籍公式较多或者代码较多还的在电脑上
    
    </summary>
    
    
      <category term="2017" scheme="http://wongchen.github.io/tags/2017/"/>
    
      <category term="总结" scheme="http://wongchen.github.io/tags/%E6%80%BB%E7%BB%93/"/>
    
  </entry>
  
  <entry>
    <title>TensorFlow 数据输入方式</title>
    <link href="http://wongchen.github.io/2017/09/11/tf-datareader/"/>
    <id>http://wongchen.github.io/2017/09/11/tf-datareader/</id>
    <published>2017-09-11T10:00:53.000Z</published>
    <updated>2018-01-17T12:50:20.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近使用TensorFlow时候发现读入图片数据的时候很难受,自己写的一些代码又感觉很蹩脚,官方的文档易读性太低,太费劲了.<br>打算好好整理一下数据输入这部分代码.</p>
<h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><h3 id="直接加载到内存中"><a href="#直接加载到内存中" class="headerlink" title="直接加载到内存中"></a>直接加载到内存中</h3><p>这种方式简直暴力,老早之前我数据没有很多,就是这么做的,把数据先用<code>pickle</code>,将其保存下来,运行的时候直接从保存的文件中获取,这种方式只适合一些小型的文本文件数据,图片数据还是算了,电脑会卡死的.</p>
<h3 id="动态输入placeholder"><a href="#动态输入placeholder" class="headerlink" title="动态输入placeholder"></a>动态输入placeholder</h3><p>在每次训练时加载一些数据到内存当中,以placeholder的形式feed到graph当中.<br>这种方式需要自己写一些代码,比如<br><figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ImageData</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">___init__</span><span class="params">(self, batch_size)</span>:</span></div><div class="line">	<span class="comment"># define some attr</span></div><div class="line">    self.batch_size = batch_size</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">next_batch</span><span class="params">(self)</span>:</span></div><div class="line">    ....</div><div class="line">	<span class="keyword">return</span> np.array([imread(<span class="string">'name%s.png'</span>%i <span class="keyword">for</span> i <span class="keyword">in</span> range(self.batch_seze))]), labels</div><div class="line">  ...</div><div class="line">  </div><div class="line">image_reader = ImageData(batch_size)</div><div class="line"><span class="keyword">for</span> step <span class="keyword">in</span> range(<span class="number">10001</span>):</div><div class="line">  batch = image_reader.next_batch()</div><div class="line">  sess.run(batch, feed_dict=&#123;x: batch[<span class="number">0</span>], y: batch[<span class="number">1</span>]&#125;)</div><div class="line">  ...</div></pre></td></tr></table></figure></p>
<p>在训练时实例化相应的类, 每次运行加载一次,需要说明的是,这样需要大量地重复读写多个小文件,所以把这些文件放到固态硬盘下面对提升读取速度是个不错的选择.</p>
<p>这个方法是比较类似于pytorch的<code>dataset</code>和<code>dataloader</code>的,同时采用pytorch的这两个类来实现TF中的数据输入也是很可行的.</p>
<p>详情见<a href="http://pytorch.org/tutorials/beginner/data_loading_tutorial.html" target="_blank" rel="external">Data Loading and Processing Tutorial</a>.</p>
<h3 id="tfrecord"><a href="#tfrecord" class="headerlink" title="tfrecord"></a>tfrecord</h3><p>TF推荐的一种文件格式为tfrecord,把多个零碎的原始文件编码为一个较大的tfrecord文件,运行时通过解码器将其转化为<code>Tensors</code>, <a href="https://www.tensorflow.org/api_guides/python/reading_data" target="_blank" rel="external">这篇tutorial</a>解释了TF中读入数据的方法,这里代码已经写得很好了,但读完发现还是不会……</p>
<p>可能用到的TF对象和方法, (先大致看名字了解一下,详细后面会涉及到):</p>
<ul>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/TFRecordReader" target="_blank" rel="external"><code>tf.TFRecordReader</code></a></li>
<li><code>tf.train.string_input_producer</code></li>
<li><code>tf.decode_raw()</code></li>
<li><code>tf.train.shuffle_batch()</code></li>
<li><a href="https://www.tensorflow.org/api_docs/python/tf/parse_single_example" target="_blank" rel="external"><code>tf.parse_single_example</code></a></li>
<li><code>tf.train.Coordinator()</code></li>
<li><code>tf.train.start_queue_runners</code></li>
</ul>
<h3 id="数据转化"><a href="#数据转化" class="headerlink" title="数据转化"></a>数据转化</h3><p>首先通过一个<code>tf.TFRecordWriter</code>对象将原始零碎小文件转化为tfrecord格式文件,代码参考某个地方的:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line">writer = tf.python_io.TFRecordWriter(<span class="string">'./data/test_deepmatching.tfrecords'</span>) <span class="comment"># 初始化TFRecordWriter对象</span></div><div class="line"></div><div class="line"><span class="comment"># write exanple</span></div><div class="line">img_raw = img.tobytes()</div><div class="line">example = tf.train.Example(features=tf.train.Features(feature=&#123;</div><div class="line">           <span class="string">'label'</span>: tf.train.Feature(int64_list=tf.train.Int64List(value=[<span class="number">1</span>])),</div><div class="line">           <span class="string">'img_raw'</span>: tf.train.Feature(bytes_list=tf.train.BytesList(value=[img_raw]))</div><div class="line">                    &#125;))</div><div class="line">writer.write(example.SerializeToString())</div><div class="line"></div><div class="line">....</div><div class="line">writer.close()</div></pre></td></tr></table></figure>
<h3 id="读入tfrecord"><a href="#读入tfrecord" class="headerlink" title="读入tfrecord"></a>读入tfrecord</h3><p>TF将文件名生成队列,并行解码读取里面的Tensors.</p>
<p><img src="https://www.tensorflow.org/images/AnimatedFileQueues.gif" alt=""></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">read_and_decode</span><span class="params">(filename)</span>:</span></div><div class="line">    filename_queue = tf.train.string_input_producer([filename])</div><div class="line">    reader = tf.TFRecordReader()</div><div class="line">    _, serialized_example = reader.read(filename_queue)  </div><div class="line">    features = tf.parse_single_example(serialized_example,</div><div class="line">               features=&#123;</div><div class="line">                   <span class="string">'label'</span>: tf.FixedLenFeature([], tf.int64),</div><div class="line">                   <span class="string">'img_raw'</span> : tf.FixedLenFeature([], tf.string),</div><div class="line">               &#125;)</div><div class="line"></div><div class="line">    img = tf.decode_raw(features[<span class="string">'img_raw'</span>], tf.uint8)</div><div class="line">    <span class="keyword">print</span> img.shape</div><div class="line">    img = tf.reshape(img, [<span class="number">65</span>, <span class="number">130</span>, <span class="number">1</span>])</div><div class="line">    <span class="comment"># img = tf.cast(img, tf.float32) * (1. / 255) - 0.5</span></div><div class="line">    <span class="comment"># pre-processing</span></div><div class="line">    label = tf.cast(features[<span class="string">'label'</span>], tf.int32)</div><div class="line">    <span class="keyword">return</span> img, label</div></pre></td></tr></table></figure>
<p>上述函数返回我们的img 和label <code>ops</code>,运行时候还需要run一下这几个ops.</p>
<p>为了实现并行读取,我们需要创建多个线程,使用<code>QueueRunner</code>兑现来运行.</p>
<p>需要一个<code>Coordnator</code>对象来管理这些线程.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">coord = tf.train.Coordinator()</div><div class="line">threads = tf.train.start_queue_runners(sess=sess, coord=coord)</div></pre></td></tr></table></figure>
<p>训练时,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">for step in range(10001):</div><div class="line">  batch = sess.run([img_batch, label_batch])</div><div class="line">  sess.run(train_op)</div><div class="line">  ...</div><div class="line">  </div><div class="line">coord.request_stop()</div></pre></td></tr></table></figure>
<p>上面这种读取不是很好,可能会遇到一些错误,导致线程无法正常关闭,还在等待读取队列,必须强行kill掉才可以,可以采用官方的代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">try:</div><div class="line">    while not coord.should_stop():</div><div class="line">        # Run training steps or whatever</div><div class="line">        sess.run(train_op)</div><div class="line"></div><div class="line">except tf.errors.OutOfRangeError:</div><div class="line">    print(&apos;Done training -- epoch limit reached&apos;)</div><div class="line">finally:</div><div class="line">    # When done, ask the threads to stop.</div><div class="line">    coord.request_stop()</div><div class="line"></div><div class="line"># Wait for threads to finish.</div><div class="line">coord.join(threads)</div><div class="line">sess.close()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近使用TensorFlow时候发现读入图片数据的时候很难受,自己写的一些代码又感觉很蹩脚,官方的文档易读性太低,太费劲了.&lt;br&gt;打算好好整理一下数据输入这部分代码.&lt;/p&gt;
&lt;h2 id=&quot;方式&quot;&gt;&lt;a href=&quot;#方式&quot; class=&quot;headerlink&quot; tit
    
    </summary>
    
      <category term="TensorFlow" scheme="http://wongchen.github.io/categories/TensorFlow/"/>
    
    
      <category term="TensorFlow" scheme="http://wongchen.github.io/tags/TensorFlow/"/>
    
  </entry>
  
  <entry>
    <title>python之context manager学习</title>
    <link href="http://wongchen.github.io/2017/09/09/python-context-manager/"/>
    <id>http://wongchen.github.io/2017/09/09/python-context-manager/</id>
    <published>2017-09-08T16:43:18.000Z</published>
    <updated>2017-09-08T09:12:35.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-context-manager"><a href="#What-is-context-manager" class="headerlink" title="What is context manager?"></a>What is context manager?</h2><blockquote>
<p>A basic issue in programming is <a href="https://en.wikipedia.org/wiki/Resource_management_(computing" target="_blank" rel="external">resource management</a>): a <a href="https://en.wikipedia.org/wiki/Resource_(computing" target="_blank" rel="external">resource</a>) is anything in limited supply, notably file handles, <a href="https://en.wikipedia.org/wiki/network_socket" target="_blank" rel="external">network sockets</a>, locks, etc., and a key problem is making sure these are <em>released</em> after they are <em>acquired.</em> If they are not released, you have a <a href="https://en.wikipedia.org/wiki/resource_leak" target="_blank" rel="external">resource leak</a>, and the system may slow down or crash. More generally, you may want cleanup actions to always be done, other than simply releasing resources.</p>
</blockquote>
<p>就像其名字一样,context manager负责管理一定的上下文环境,按照你的设定,及时<strong>分配</strong>一定的资源,在完成相应的工作之后,及时<strong>释放</strong>这些资源. 而且不止是释放资源,你还可以做其他你想的事情……</p>
<p>Python提供了一种特定的语法结构可以用来做如此工作,许多类型都支持context text,比如buit-in <code>File</code>对象.</p>
<p>常用的操作</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">with open(file_name, &apos;rb&apos;) as f:</div><div class="line">	lines = f.readlines()</div><div class="line">	# other opoerations</div><div class="line">	</div><div class="line">print f.closed    # True</div></pre></td></tr></table></figure>
<p>i.e.在这个例子里context manager会自动关闭f文件对象,不需要用户显示地执行代码关闭,更加安全.</p>
<p>仔细研究会发现,这类对象,需要实现<code>__enter__</code>和<code>__exit__</code>两个方法属性,上面的例子等价于</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">f = open(file_name, <span class="string">'rb'</span>)</div><div class="line">f.__enter__()</div><div class="line"><span class="keyword">try</span>:</div><div class="line">  BLOCK Operations</div><div class="line"><span class="keyword">finally</span>:</div><div class="line">  f.__exit__()</div></pre></td></tr></table></figure>
<h2 id="How-to-implement"><a href="#How-to-implement" class="headerlink" title="How to implement?"></a>How to implement?</h2><p>首先,通过实现<code>__enter__</code>和<code>__exit__</code>这两个协议方法,我们可以使用<code>with expre [as var]:</code>语法来使用context manager.如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">class File(object):</div><div class="line">    def __init__(self, file_name, method):</div><div class="line">        self.file_obj = open(file_name, method)</div><div class="line">    def __enter__(self):</div><div class="line">        return self.file_obj</div><div class="line">    def __exit__(self, type, value, traceback):</div><div class="line">        self.file_obj.close()</div></pre></td></tr></table></figure>
<p><code>__enter__</code>将返回值传入<code>as</code>后面的<code>var</code>变量,<code>block</code>退出时执行<code>__exit__</code>方法,更通常一些,<code>__exit__</code>方法应该返回一个<code>bool</code>值表示是否发生异常. 基于以上<code>File</code>类的定义可以使用下面的<code>with</code>statement.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">with File(&apos;demo.txt&apos;, &apos;w&apos;) as opened_file:</div><div class="line">    opened_file.write(&apos;Hola!&apos;)</div></pre></td></tr></table></figure>
<p>处理异常也基本同理.</p>
<h2 id="contextlib-Utilities-for-with-statement-contexts"><a href="#contextlib-Utilities-for-with-statement-contexts" class="headerlink" title="contextlib:  Utilities for with-statement contexts"></a>contextlib:  Utilities for <a href="https://docs.python.org/2/reference/compound_stmts.html#with" target="_blank" rel="external"><code>with</code></a>-statement contexts</h2><p>看一下这个built-in moudule<code>contextlib</code></p>
<blockquote>
<p>This module provides utilities for common tasks involving the <a href="https://docs.python.org/2/reference/compound_stmts.html#with" target="_blank" rel="external"><code>with</code></a> statement. For more information see also <a href="https://docs.python.org/2/library/stdtypes.html#typecontextmanager" target="_blank" rel="external">Context Manager Types</a> and <a href="https://docs.python.org/2/reference/datamodel.html#context-managers" target="_blank" rel="external">With Statement Context Managers</a>.</p>
</blockquote>
<h3 id="contextlib-contextmanager"><a href="#contextlib-contextmanager" class="headerlink" title="contextlib.contextmanager"></a>contextlib.contextmanager</h3><p>官方的例子是:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">from contextlib import contextmanager</div><div class="line"></div><div class="line">@contextmanager</div><div class="line">def tag(name):</div><div class="line">    print &quot;&lt;%s&gt;&quot; % name</div><div class="line">    yield</div><div class="line">    print &quot;&lt;/%s&gt;&quot; % name</div><div class="line"></div><div class="line">&gt;&gt;&gt; with tag(&quot;h1&quot;):</div><div class="line">...    print &quot;foo&quot;</div><div class="line">...</div><div class="line">&lt;h1&gt;</div><div class="line">foo</div><div class="line">&lt;/h1&gt;</div></pre></td></tr></table></figure>
<p>这个函数是个decorator函数,参考之前的<a href="https://wongchen.github.io/2017/08/19/python-decorator/">一篇</a>,它可以将函数包装为context manager,无需自己显示为其实现<code>__enter__</code>和<code>__exit__</code>方法.</p>
<p>这个函数返回一个iterator,可以使用<code>yield</code>关键字</p>
<blockquote>
<p>At the point where the generator yields, the block nested in the <a href="https://docs.python.org/2/reference/compound_stmts.html#with" target="_blank" rel="external"><code>with</code></a> statement is executed.</p>
</blockquote>
<p>yield之后,便会执行块下的内容.</p>
<p>改写上面的例子为</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">@contextmanager</div><div class="line">def opened(filename, mode=&quot;r&quot;):</div><div class="line">    f = open(filename, mode)</div><div class="line">    try:</div><div class="line">        yield f</div><div class="line">    finally:</div><div class="line">        f.close()</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;What-is-context-manager&quot;&gt;&lt;a href=&quot;#What-is-context-manager&quot; class=&quot;headerlink&quot; title=&quot;What is context manager?&quot;&gt;&lt;/a&gt;What is context 
    
    </summary>
    
      <category term="python" scheme="http://wongchen.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://wongchen.github.io/tags/python/"/>
    
      <category term="content manager" scheme="http://wongchen.github.io/tags/content-manager/"/>
    
  </entry>
  
  <entry>
    <title>python之generator学习</title>
    <link href="http://wongchen.github.io/2017/08/20/python-generator/"/>
    <id>http://wongchen.github.io/2017/08/20/python-generator/</id>
    <published>2017-08-19T16:43:18.000Z</published>
    <updated>2017-09-14T16:57:21.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>先看一个问题: 假设我们遇到一个需要长时间响应才能得到返回值的情境,比如深度学习中的大计算或者网络较长时间的响应等(这里我们用<code>sleep()</code>函数来代替),每次需要较长时间的计算才能得到结果.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_compute</span><span class="params">()</span>:</span></div><div class="line">  rv = list()</div><div class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    sleep(<span class="number">2</span>)</div><div class="line">    rv.append(i)</div><div class="line">  <span class="keyword">return</span> rv</div></pre></td></tr></table></figure>
<p>如上面所述,假如我想得到的最终结果含10个值,我需要20秒才能观察到最后结果,但是假如包含更长的值(如100呢)而且我想观察前几个值呢? 因为从前几个值就能发现一些有意义的东西,我不需要观察全部的值就能得到我想要的,怎么办?</p>
<p>明显要等到全部值计算完都返回是不符合逻辑的,如果我们只是观察结果不用到返回值的情况可以每次都<code>print</code>打印出每次的结果,但是这也不能解决所有的情况. 幸运的是我们可以通过<code>generator</code>来解决这种问题.</p>
<h2 id="What-is-python-Generator"><a href="#What-is-python-Generator" class="headerlink" title="What is python Generator?"></a>What is python Generator?</h2><blockquote>
<p>Introduced in Python 2.2 as an optional feature and finalized in version 2.3, <a href="https://en.wikipedia.org/wiki/Generator_(computer_science)" target="_blank" rel="external">generators</a> are Python’s mechanism for <a href="https://en.wikipedia.org/wiki/Lazy_evaluation" target="_blank" rel="external">lazy evaluation</a> of a function that would otherwise return a space-prohibitive or computationally intensive list.</p>
<p>A Python <em>generator</em> is a function which returns a <em>generator iterator</em> (just an object we can iterate over) by calling <code>yield</code>. <code>yield</code> may be called with a value, in which case that value is treated as the “generated” value. The <em>next time</em><code>next()</code> is called on the <em>generator iterator</em> (i.e. in the next step in a <code>for</code> loop, for example),the generator resumes execution <em>from where it called yield</em>, not from the beginning of the function. All of the state, like the values of local variables, is recovered and the generator contiues to execute until the next call to <code>yield</code>.</p>
</blockquote>
<p>generator可以不像一般的函数那样,一次返回一个值,下一次还在上次执行的地方继续运行程序返回下一个值,可以说是返回一系列值(One at a time). </p>
<h3 id="Generator-expressions"><a href="#Generator-expressions" class="headerlink" title="Generator expressions"></a>Generator expressions</h3><blockquote>
<p>Introduced in Python 2.4, generator expressions are the lazy evaluation equivalent of list comprehensions. </p>
</blockquote>
<p>不同于生成器,生成器表达式是<code>list comprehensions</code>的generator形式表达.与<code>list comprehensions</code>长得很像,但是返回一个generator而不是list.</p>
<p>此外,generator不能用下标来索引.</p>
<p>如下, 详细后面叙述.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = (x for x in range(8))</div><div class="line">&gt;&gt;&gt; a</div><div class="line">&lt;generator object &lt;genexpr&gt; at 0x104684960&gt;</div><div class="line">&gt;&gt;&gt; a[2]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: &apos;generator&apos; object has no attribute &apos;__getitem__&apos;</div></pre></td></tr></table></figure>
<h2 id="如何"><a href="#如何" class="headerlink" title="如何"></a>如何</h2><p>对于开始提出的问题,如何使用generator来解决呢?</p>
<p>我们最后想要的是一个可以迭代的对象,大致为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = iter(rv)</div><div class="line">next_value = next(x)</div></pre></td></tr></table></figure>
<p>我们知道python中许多方法和属性都是有对应的double underscore属性和方法的(如<code>__add__</code>).上面的对应为<code>__iter__</code>(python2中是<code>next()</code>)和<code>__next__</code>方法.</p>
<p>于是我们可以使用一个类,实现上述两种方法来实现generator.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputerLong</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">    self.last = <span class="number">0</span></div><div class="line">    <span class="keyword">return</span> self</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line">    rv = self.last</div><div class="line">    self.last += <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> self.last &gt; <span class="number">10</span>:</div><div class="line">      <span class="keyword">raise</span> StopIteration()</div><div class="line">    sleep(<span class="number">2</span>)</div><div class="line">    <span class="keyword">return</span> rv</div></pre></td></tr></table></figure>
<p>但是这样读起来太费劲了,正常点的写法还是应该像上面函数那样. 更Generator的写法应该使用<code>yield</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_compute</span><span class="params">()</span>:</span></div><div class="line">  rv = list()</div><div class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    sleep(<span class="number">2</span>)</div><div class="line">    <span class="keyword">yield</span> i</div><div class="line"> <span class="comment">#   rv.append(i)</span></div><div class="line"> <span class="comment"># return rv</span></div></pre></td></tr></table></figure>
<p>Generator每次生成一个新的值时,采用<code>yield</code>关键字代替原来return的位置,相当于返回一个需要即可取的值.</p>
<p>Generator返回是一个可迭代的对象,因此可以使用<code>for</code>循环:</p>
<p>每次<code>for</code>循环中需要一个值时,便会调用generator对象的next()方法,取回一个值.</p>
<h2 id="generator结束"><a href="#generator结束" class="headerlink" title="generator结束"></a>generator结束</h2><p>当generator函数中使用return或者generator迭代到最后,将会返回一个<code>StopIteration</code> exception,当next到最后一个值时将会报错,因此generator只能够循环一次.</p>
<p><img src="/images/Screenshot2017-08-23_%E4%B8%8B%E5%8D%8810.27.24.png" alt=""></p>
<p>最后:</p>
<ul>
<li>generator可以用来返回一个迭代器,可以返回一个序列(每次一个值而不是直接全部的返回值).</li>
<li>yield可以看做next()方法return一个值并记住这个位置,下次在这个位置利用next()方法仍旧如此.</li>
<li>python2中generator next()方法为<code>g.next()</code>,而python3为<code>g.__next__()</code></li>
</ul>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h2&gt;&lt;p&gt;先看一个问题: 假设我们遇到一个需要长时间响应才能得到返回值的情境,比如深度学习中的大计算或者网络较长时间的响应等(这里我们用&lt;code&gt;s
    
    </summary>
    
      <category term="python" scheme="http://wongchen.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://wongchen.github.io/tags/python/"/>
    
      <category term="generator" scheme="http://wongchen.github.io/tags/generator/"/>
    
  </entry>
  
  <entry>
    <title>学习python中的Decorator</title>
    <link href="http://wongchen.github.io/2017/08/19/python-decorator/"/>
    <id>http://wongchen.github.io/2017/08/19/python-decorator/</id>
    <published>2017-08-19T12:28:27.000Z</published>
    <updated>2017-08-23T13:10:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-a-Decorator"><a href="#What-is-a-Decorator" class="headerlink" title="What is a Decorator?"></a>What is a Decorator?</h2><p>参考<a href="https://en.wikipedia.org/wiki/Decorator_pattern" target="_blank" rel="external">Decorator Pattern wiki</a>,(这个维基词条多讲得是Java/C#/C++相关,但是与python中的实现的功能类似.)</p>
<blockquote>
<p>A decorator is the name used for a software design pattern. Decorators dynamically alter the functionality of a function, method, or class without having to directly use subclasses or change the source code of the function being decorated.</p>
<p><strong>修饰模式</strong>，是<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B" target="_blank" rel="external">面向对象编程</a>领域中，一种动态地往一个类中添加新的行为的<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">设计模式</a>。就功能而言，修饰模式相比生成<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%B1%BB" target="_blank" rel="external">子类</a>更为灵活，这样可以给某个对象而不是整个类添加一些功能。</p>
<p>通过使用修饰模式，可以在运行时扩充一个类的功能。原理是：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators" target="_blank" rel="external">Python Decorator</a>:</p>
<blockquote>
<p>A decorator is any callable Python object that is used to modify a function, method or class definition. A decorator is passed the original object being defined and returns a modified object, which is then bound to the name in the definition. Python decorators were inspired in part by <a href="https://en.wikipedia.org/wiki/Java_annotation" target="_blank" rel="external">Java annotations</a>, and have a similar syntax; the decorator syntax is pure <a href="https://en.wikipedia.org/wiki/Syntactic_sugar" target="_blank" rel="external">syntactic sugar</a>, using <code>@</code> as the keyword:</p>
</blockquote>
<p>在python中,Decorator与<a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="external">函数式编程(Functional Programming)</a>和<a href="https://en.wikipedia.org/wiki/Metaprogramming" target="_blank" rel="external">元编程(Metaprogramming)</a>息息相关,可以用Decorator来修改一个函数,类以及类的定义.</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>接下来举几个简单例子说明python中为何要使用Decorator.</p>
<ol>
<li><p>更加简明,易读</p>
<p>如下面两个例子,分别要实现一个classmethod方法和测试函数试行时间的功能,但是函数的定义和最后要实现的功能处出现了分离,对函数的操作变换代码出现在了函数的后面位置,不管是代码复杂性和逻辑都有问题.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</div><div class="line"><span class="comment"># example 1: a classmethod function</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></div><div class="line">	do_something</div><div class="line">foo = classmethod(foo)</div><div class="line"></div><div class="line"><span class="comment"># example 2: timer for a function</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">	do_something</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">decor_fun</span><span class="params">()</span>:</span></div><div class="line">		start_time = time()</div><div class="line">		func()</div><div class="line">		print(<span class="string">"Cost time: "</span>, time()-start_time)</div><div class="line">	<span class="keyword">return</span> decor_fun</div><div class="line">foo = timer(foo)</div></pre></td></tr></table></figure>
<p>通过Decorator更加直观,明了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</div><div class="line"><span class="comment"># example 1</span></div><div class="line"><span class="meta">@classmethod</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(cls)</span>:</span></div><div class="line">  do_something</div><div class="line">  </div><div class="line"><span class="comment"># example 2</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">decor_fun</span><span class="params">()</span>:</span></div><div class="line">		start_time = time()</div><div class="line">		func()</div><div class="line">		print(<span class="string">"Cost time: "</span>, time()-start_time)</div><div class="line">	<span class="keyword">return</span> decor_fun</div><div class="line">  </div><div class="line"><span class="meta">@timer</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">  do_something</div></pre></td></tr></table></figure>
</li>
<li><p>实现特定的功能</p>
<p>参考<a href="https://www.zhihu.com/question/20021164" target="_blank" rel="external">这个知乎问题:Python 中的 classmethod 和 staticmethod 有什么具体用途?</a>,还可以结合函数式编程,某个函数功能需要被其他多个函数重复实现时,可以考虑Decorator,如: example 2测试函数运行时间, 输出log日志等等.</p>
</li>
</ol>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>通过example 2以及<a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators" target="_blank" rel="external">python Decorator Wiki</a>不难看出<code>@</code>符号其实是以要定义的函数<code>foo</code>作为参数传入<code>@</code>后面的函数<code>bar</code>中,返回一个新的同时实现两者功能的函数.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@bar</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">  <span class="keyword">return</span> <span class="string">"foo"</span></div><div class="line"></div><div class="line"><span class="comment"># 等价于以下的  bar(foo)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">  print(<span class="string">"foo"</span>)</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(func)</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func_decor</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"bar/"</span>+func())  </div><div class="line">  <span class="keyword">return</span> func_decor</div></pre></td></tr></table></figure>
<h3 id="带参数呢"><a href="#带参数呢" class="headerlink" title="带参数呢?"></a>带参数呢?</h3><p>如果接触过函数式编程的话,不难解决这个问题,更普遍的方法可以使用<code>*args</code>和<code>**kwargs</code>关键字,针对带有默认参数和不带有默认参数的函数都可以解决.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func, *args, **kwargs)</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">decor_func</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">    start_time = time()</div><div class="line">    ans = func(*args, **kwargs)</div><div class="line">    print(<span class="string">"cost time: "</span>, time()-start_time)</div><div class="line">    <span class="keyword">return</span> ans</div><div class="line">  <span class="keyword">return</span> decor_func</div><div class="line"></div><div class="line"><span class="meta">@timer</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2</span><span class="params">(x, y=<span class="number">66</span>)</span>:</span></div><div class="line">  <span class="keyword">return</span> x + y</div></pre></td></tr></table></figure>
<p>另外,Decorator也是可以输入参数的,还是上一个例子,实现调用n次函数.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def ntimes(n):</div><div class="line">  def innner(func)</div><div class="line">  	def wrapper(*args, **kwargs):</div><div class="line">	  for _ in range(n):</div><div class="line">        print("calling function %s"%func.__name__)</div><div class="line">        ans = func(*args, **kwargs)</div><div class="line">      return ans</div><div class="line">    return wrapper</div><div class="line">  return inner</div><div class="line">n = 10</div><div class="line">@ntimes(10)</div><div class="line">def add2(x, y=66):</div><div class="line">  return x + y</div></pre></td></tr></table></figure>
<p>本例中,从函数式编程角度看,深度更深了一层,从<code>@</code>本质理解,其后符号ntimes也是函数,故也可接受参数,一般Decorator不会比这个更深,所以了解即可. 详情可以了解<a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Closures" target="_blank" rel="external">python中的闭包</a>.</p>
<h3 id="多个Decorator"><a href="#多个Decorator" class="headerlink" title="多个Decorator"></a>多个Decorator</h3><p>道理都是类似的,语法为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@dec2</span></div><div class="line"><span class="meta">@dec1</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg1, arg2, ...)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<h2 id="Class-Decorator"><a href="#Class-Decorator" class="headerlink" title="Class Decorator"></a>Class Decorator</h2><blockquote>
<p>In Python prior to version 2.6, decorators apply to functions and methods, but not to classes. Decorating a (dummy) <code>__new__</code> method can modify a class, however.<a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#cite_note-28" target="_blank" rel="external">[25]</a>Class decorators are supported<a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#cite_note-29" target="_blank" rel="external">[26]</a> starting with Python 2.6.</p>
</blockquote>
<p>Python 2.6之后才支持class decorators,之前都是通过metaclass来实现相应功能,<code>__new__</code>方法修改类.</p>
<p>按照之前的解释,Class Decorator与Function Decorator应该是基本相同的,只是装饰的对象不同而已.</p>
<h3 id="Decorator-作用整个类"><a href="#Decorator-作用整个类" class="headerlink" title="Decorator 作用整个类"></a>Decorator 作用整个类</h3><p>可以看到此时的decorator接受一个类作为函数参数,返回一个修饰之后的类,跟之前一样的道理.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(cls)</span>:</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span><span class="params">(object)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></div><div class="line">            self.wrapped = cls(*args)</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></div><div class="line">            print(<span class="string">'Getting the &#123;&#125; of &#123;&#125;'</span>.format(name, self.wrapped))</div><div class="line">            <span class="keyword">return</span> getattr(self.wrapped, name)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> Wrapper</div><div class="line"></div><div class="line"><span class="meta">@decorator</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></div><div class="line">        self.x = x</div><div class="line">        self.y = y</div></pre></td></tr></table></figure>
<h3 id="Decorator本身是类"><a href="#Decorator本身是类" class="headerlink" title="Decorator本身是类"></a>Decorator本身是类</h3><p>如下面例子所示,</p>
<p><code>__init__</code>方法接受要修饰的函数为参数.</p>
<p><code>__call__</code>方法在调用被修饰函数时调用.</p>
<p>此外还有<code>__set__</code>, <code>__get__</code>, <code>__getattribute__</code>等方法均可修改.    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">decorator</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></div><div class="line">        self.func = func</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args)</span>:</span></div><div class="line">        print(<span class="string">'Called &#123;func&#125; with args: &#123;args&#125;'</span>.format(func=self.func.func_name,</div><div class="line">                                                       args=args))</div><div class="line">        <span class="keyword">return</span> self.func(*args)</div><div class="line"></div><div class="line"><span class="meta">@decorator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x,y)</span>:</span></div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line"></div><div class="line">func(<span class="number">1</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>从这个角度看,Decorator可以实现修改调用模型的这一功能. 可以参考<a href="https://www.ibm.com/developerworks/cn/linux/l-cpdecor.html" target="_blank" rel="external">修改调用模型</a>.</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>仔细研读细节就会发现,使用decorator可以完成期望的功能,取得成效,但是也会带来代码细节与原本出现偏差的问题,毕竟对了一层调用,改进方法可以使用 <code>functools</code>的<code>wraps</code>Decorator.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_decorator</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">  @wraps(f)</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">    func(*args, **kwargs)</div><div class="line">  <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure>
<p>也可以使用decorator.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> decorator</div><div class="line"></div><div class="line"><span class="meta">@decorator	</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_decorator</span><span class="params">(func)</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">    func(*args, **kwargs)</div><div class="line">  <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;What-is-a-Decorator&quot;&gt;&lt;a href=&quot;#What-is-a-Decorator&quot; class=&quot;headerlink&quot; title=&quot;What is a Decorator?&quot;&gt;&lt;/a&gt;What is a Decorator?&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
      <category term="python" scheme="http://wongchen.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://wongchen.github.io/tags/python/"/>
    
      <category term="decorator" scheme="http://wongchen.github.io/tags/decorator/"/>
    
  </entry>
  
  <entry>
    <title>我的KeyboardMaestro宏</title>
    <link href="http://wongchen.github.io/2016/12/09/myKeyboardMaestroActions/"/>
    <id>http://wongchen.github.io/2016/12/09/myKeyboardMaestroActions/</id>
    <published>2016-12-09T08:16:00.000Z</published>
    <updated>2017-08-08T15:27:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.keyboardmaestro.com/main/" target="_blank" rel="external">Keyboard Maestro</a>作为Mac下出名的效率软件,有着不菲的名声,是<strong>Winner of a Macworld Editors’ Choice Award for 2013.</strong></p>
<p>官网的介绍是:</p>
<blockquote>
<p>Whether you are a power user or a grandparent (or both!), your time is precious. So why waste it when Keyboard Maestro can help improve almost every aspect of using your Mac. Even the simplest things, like typing your email address, or going to Gmail or Facebook, launching Pages, or duplicating a line, all take time and add frustration. <strong>Let Keyboard Maestro help make your Mac life more pleasant and efficient.</strong></p>
</blockquote>
<p>工欲善其事必先利其器,在使用Mac工作学习的过程中发现一些跟之前使用习惯不适应和”稍微反人类的”一些操作,比如在Finder中的<em>“在当前目录打开终端”</em>等操作,因此想到了Keyboard Maestro,通过它来简化一些操作将大大提高效率,也更加简便.</p>
<p>然后在这里简单介绍我常用的一些宏(<strong>常更新哦</strong>)</p>
<h2 id="Finder"><a href="#Finder" class="headerlink" title="Finder"></a>Finder</h2><p>Finder作为使用率最高的软件之一,首先介绍Finder相关的宏.由于快捷键太难记忆而决定采用Palette,Finder不会占据太大的空间,因此Palette也不会出现遮挡Finder窗口的问题.</p>
<p><img src="/images/palette.png" alt="finder palette"></p>
<p>显示为</p>
<p><img src="/images/finder_palette.png" alt="finder palette display"></p>
<ul>
<li>在Finder中显示”在terminal中打开”,很简单如下图实现</li>
</ul>
<p><img src="/images/finder_terminal.png" alt="finder terminal"></p>
<ul>
<li>新建文件(<strong>文件名自行输入</strong>)</li>
</ul>
<p>由于Keyboard Maestro支持Apple Script,因此可以通过如下代码实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tell application &quot;Finder&quot;</div><div class="line">	set annoying_path to the target of the front window as text</div><div class="line">	set actual_path to POSIX path of annoying_path</div><div class="line">	set something to display dialog &quot;File name?&quot; default answer &quot;&quot;</div><div class="line">	set textReturned to text returned of something</div><div class="line">	set newFileName to actual_path &amp; textReturned</div><div class="line">	set accessNum to open for access newFileName with write permission</div><div class="line">end tell</div></pre></td></tr></table></figure>
<p>点击<code>&quot;新建文件&quot;</code>时,会提示窗口输入文件名</p>
<p><img src="/images/fider_new_file.png" alt="new file"></p>
<ul>
<li>复制文件名</li>
</ul>
<p>只需如下脚本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tell application &quot;Finder&quot;</div><div class="line">	set theFile to the selection</div><div class="line">	set fileName to name of item 1 of theFile</div><div class="line">	set the clipboard to fileName</div><div class="line">end tell</div></pre></td></tr></table></figure>
<p>另外Mac自带的<strong>脚本编辑器</strong>,可以编写运行Apple Script,在写脚本时可以用它写完测试ok后再复制到Keyboard Maestro中.</p>
<ul>
<li>复制文件绝对路径</li>
</ul>
<p>有时在终端下工作时,或者其他环境中需要某一文件的路径,这时候使用绝对路径会是有效可靠且方便的,同样脚本为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tell application &quot;Finder&quot;</div><div class="line">	set sel to the selection</div><div class="line">	set the clipboard to POSIX path of (sel as text)</div><div class="line">end tell</div></pre></td></tr></table></figure>
<p>结合Apple Script, Keyboard Maestro可以发挥更加强大的功能,慢慢通过不断的需求和学习可以开发出更多新的功能</p>
<h2 id="Launch-Apps"><a href="#Launch-Apps" class="headerlink" title="Launch Apps"></a>Launch Apps</h2><p>对于一些常用的应用程序可以设定某些快捷键,方便快速启动,就像在Linux下面,<code>Alt</code> <code>+</code> <code>control</code> <code>+</code>  <code>T</code> 开启终端,win下面, <code>win</code> <code>+</code> <code>D</code>开启文件管理器.</p>
<p>我常用的如:</p>
<p><img src="/images/launch_app_lists.png" alt="launch apps"></p>
<p>设定自己习惯,容易记忆的快捷键即可.</p>
<p>另外,发现每次截图之后想要寻找截图照片变得繁杂,因此每次截图后主动在Finder下显示截图目录</p>
<p><img src="/images/screeshots_finder.png" alt="截图 弹窗"></p>
<p>(逐渐更新中….)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.keyboardmaestro.com/main/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Keyboard Maestro&lt;/a&gt;作为Mac下出名的效率软件,有着不菲的名声,是&lt;strong&gt;Winner 
    
    </summary>
    
      <category term="Mac配置" scheme="http://wongchen.github.io/categories/Mac%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Keyboard Maestro" scheme="http://wongchen.github.io/tags/Keyboard-Maestro/"/>
    
  </entry>
  
  <entry>
    <title>Mac下安装软件包遇到的错误总结</title>
    <link href="http://wongchen.github.io/2016/11/22/mac-uninstall-pip-packages/"/>
    <id>http://wongchen.github.io/2016/11/22/mac-uninstall-pip-packages/</id>
    <published>2016-11-21T16:30:37.000Z</published>
    <updated>2017-09-14T17:06:51.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在装一些软件包的时候,总遇到一些很难解决的错误,总结下:</p>
<h2 id="scipy-seaborn"><a href="#scipy-seaborn" class="headerlink" title="scipy, seaborn"></a>scipy, seaborn</h2><p>Python的包我都是采用pip来安装的</p>
<blockquote>
<p>SciPy (pronounced “Sigh Pie”) is a Python-based ecosystem of open-source software for mathematics, science, and engineering. In particular, these are some of the core packages:</p>
</blockquote>
<ul>
<li>NumPy</li>
<li>SciPy</li>
<li>Matplotlib</li>
<li>IPython</li>
<li>Sympy</li>
<li>pandas</li>
</ul>
<p>Seaborn的话,</p>
<blockquote>
<p>Seaborn is a Python visualization library based on matplotlib. It provides a high-level interface for drawing attractive statistical graphics.</p>
</blockquote>
<p>但是,我用<code>pip install seaborn</code>后,import时,出现<font color="red">ERROR</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">from . import futil</div><div class="line">ImportError: cannot import name futil</div></pre></td></tr></table></figure>
<p>在这之前还有个错误,这个跟个人习惯有关,我在本地创建的一个<code>new.py</code>的文件,正好seaborn导入时会用到<code>new.py</code>,由Python包导入顺序此时本地的<code>new</code>要优先于seaborn的<code>new</code>,这个”案子”提示我们自我创建文件时</p>
<ol>
<li>目录要准确</li>
<li>名字不要太容易起冲突</li>
</ol>
<p>不过这类错误一眼也能看出来.<br>回到刚那个错误,搜索很久,发现安装的<code>SciPy</code>应该是一个Broken的版本(到那个目录查看的话,会发现<code>futil.so</code>这个文件),更新下就好了.然而,这货根本卸载不掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OSError: [Errno 1] Operation not permitted: &apos;/tmp/pip-JPaA5b-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy-0.13.0b1-py2.7.egg-info&apos;</div></pre></td></tr></table></figure>
<p>参考<a href="http://xiaorui.cc/2016/03/27/%E8%A7%A3%E5%86%B3mac-osx%E4%B8%8Bpip%E5%AE%89%E8%A3%85ipython%E6%9D%83%E9%99%90%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="external">解决mac osx下pip安装ipython权限的问题</a>,终于解决了.</p>
<blockquote>
<p>由于El Capitan引入了SIP机制(System Integrity Protection),默认下系统启用SIP系统完整性保护机制，无论是对于硬盘还是运行时的进程限制对系统目录的写操作。<br>  现在的解决办法是取消SIP机制，具体做法是：<br>重启电脑，按住Command+R(直到出现苹果标志)进入Recovery Mode(恢复模式)<br>左上角菜单里找到实用工具 -&gt; 终端<br>输入csrutil disable回车<br>重启Mac即可<br>如果想重新启动SIP机制重复上述步骤改用csrutil enable即可.</p>
</blockquote>
<p>这下好了,然而运行下面这段代码时发现,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sns.set_style(&quot;whitegrid&quot;)</div><div class="line">data = np.random.normal(size=(20, 6)) + np.arange(6) / 2</div><div class="line">sns.boxplot(data=data);</div></pre></td></tr></table></figure>
<p>这根本什么都没有,什么都没有,其实这个问题很早就有了……</p>
<p><a href="https://www.zhihu.com/question/35169072" target="_blank" rel="external">知乎</a><br><a href="http://stackoverflow.com/questions/2512225/matplotlib-not-showing-up-in-mac-osx" target="_blank" rel="external">stack<strong>overflow</strong></a></p>
<p>都这么长时间了,真是的,尝试了下面的所有方法,只有<code>plt.show()</code>这个方法能使.但是,这个”小火箭”,便退不出去了<img src="/images/python_sns.png" alt="python sns"><br>不过<code>sns.plt</code>倒是有很多功能,应该能够实现我们想要的.</p>
<h2 id="VTK"><a href="#VTK" class="headerlink" title="VTK"></a>VTK</h2><p>全称是<strong>The Visulition ToolKit</strong>, 有<a href="http://www.vtk.org/Wiki/Main_Page" target="_blank" rel="external">wiki</a>.</p>
<p>安装完遇到的第一个问题便是几个examples的cxx版本,几乎什么都没有<br><img src="http://g.recordit.co/TWfNFkfk2y.gif" alt="NoneVtk"><br>似乎是VTK版本更新后,出现了这些问题,我不知道了.不过还是有其他例子可以显示的.</p>
<p>有些例子中包含vtkRenderWindowInteractor`即VTK交互渲染窗口是可以正常显示的,但是其他就不行了.</p>
<p>后来发现解决方法:</p>
<p>举例来说,如这个<a href="https://github.com/Kitware/VTK/blob/master/Examples/Tutorial/Step1/Cxx/Cone.cxx" target="_blank" rel="external">例子</a>是VTK官方的Toturial中的step1,在cxx源代码中加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">// &lt;...step1 code...&gt;</div><div class="line"> for (i = 0; i &lt; 360; ++i) //每次渲染窗口时通过usleep函数,可以让窗口保留显示一段时间</div><div class="line">  &#123;</div><div class="line">    usleep(microseconds);</div><div class="line"></div><div class="line">    // render the image</div><div class="line">    renWin-&gt;Render();</div><div class="line">    // rotate the active camera by one degree</div><div class="line">    ren1-&gt;GetActiveCamera()-&gt;Azimuth( 1 );</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>安装MITK时,用Cmake编译好久,错误好多,无法解决</li>
<li>安装Qt5,遇到错误</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Project ERROR: Xcode not set up properly. You may need to confirm the license agreement by running /usr/bin/xcodebuild</div></pre></td></tr></table></figure>
<p>后来发现是个某个版本的bug,换了其他方式安装合适的版本后ok了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在装一些软件包的时候,总遇到一些很难解决的错误,总结下:&lt;/p&gt;
&lt;h2 id=&quot;scipy-seaborn&quot;&gt;&lt;a href=&quot;#scipy-seaborn&quot; class=&quot;headerlink&quot; title=&quot;scipy, seaborn&quot;&gt;&lt;/a&gt;scipy, s
    
    </summary>
    
      <category term="Mac配置" scheme="http://wongchen.github.io/categories/Mac%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="mac" scheme="http://wongchen.github.io/tags/mac/"/>
    
      <category term="pip" scheme="http://wongchen.github.io/tags/pip/"/>
    
      <category term="vtk" scheme="http://wongchen.github.io/tags/vtk/"/>
    
      <category term="seaborn" scheme="http://wongchen.github.io/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>IPv6环境使用Goagent代理免校园网流量</title>
    <link href="http://wongchen.github.io/2016/11/13/gae-proxy-ipv6/"/>
    <id>http://wongchen.github.io/2016/11/13/gae-proxy-ipv6/</id>
    <published>2016-11-13T14:49:58.000Z</published>
    <updated>2017-09-14T08:01:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ipv6"><a href="#ipv6" class="headerlink" title="ipv6"></a>ipv6</h2><p>If you ask Google “What is ipv6 ?”, the first entry it will display says that</p>
<blockquote>
<p>Internet Protocol Version 6 (IPv6) is a network layer protocol that enables data communications over a packet switched network. Packet switching involves the sending and receiving of data in packets between two nodes in a network. </p>
</blockquote>
<p>用中文讲,就是</p>
<blockquote>
<p>互联网通信协议第6版（英文：Internet Protocol version 6，缩写：IPv6）是互联网协议的最新版本，用于分组交换互联网络的网络层协议，旨在解决IPv4地址枯竭问题。<br>  IPv6意图替换IPv4，而IPv4在2014年5月仍然在网络交通上占有96%。[1][2][3]在2014年10月，通过IPv6使用Google服务的用户百分率首次超过5%。</p>
</blockquote>
<p>  教育网由于采用IPv6,有它固有的优势</p>
<ul>
<li>地址容量大大扩展，由原来的32位扩充到128位，彻底解决IPv4地址不足的问题；支持分层地址结构，从而更易于寻址；扩展支持组播和任意播地址，这使得数据包可以发送给任何一个或一组节点；</li>
<li>大容量的地址空间能够真正的实现无状态地址自动配置，使IPv6终端能够快速连接到网络上，无需人工配置，实现了真正的即插即用；</li>
<li>…… 其实我是不懂的</li>
</ul>
<h2 id="GoAgent"><a href="#GoAgent" class="headerlink" title="GoAgent"></a>GoAgent</h2><p>From <a href="https://zh.wikipedia.org/wiki/GoAgent" target="_blank" rel="external">Wikepidia</a>,</p>
<blockquote>
<p>GoAgent是使用跨平台语言Python开发、基于GPL自由软件协议的代理软件。它利用Google App Engine（GAE）的服务器充当代理。从2015年8月以后，GoAgent已停止维护，并被开发者删除。不过，GoAgent作者phuslu于2015年3月开始开发的另一个翻墙软件GoProxy仍处于活跃维护状态。</p>
</blockquote>
<p>虽然那会儿停止维护了,但是我发现虽然IPv4的IP不能使了,IPv6还是OK的.于是我就大部分时间一直都在用它,用到现在.</p>
<p>具体怎么用就不说了,BTW,需要开启IPv6,在<code>local/proxy.ini</code>配置文件中,修改<code>ipv6=1</code><br><img src="/images/ipv6.png" alt="ipv6"></p>
<h3 id="浏览器使用"><a href="#浏览器使用" class="headerlink" title="浏览器使用"></a>浏览器使用</h3><p><code>chrome</code> 配合插件 <code>SwitchyOmega</code>,修改规则<br>代理类型<em>HTTP</em>,服务器 <em>127.0.0.1</em> ,端口 <em>8087</em>,也可以使用备份文件恢复.<br>需要注意的是,完了需要信任其证书.</p>
<p>在线看YouTube还是很快的,经常看Apple/Google 发布会 Live stream,还有NBA 的Live,还有Udacity和Coursera上面的课程……资源还是很多的,速度也基本ok.<br><img src="/images/youtube.png" alt="youtube"></p>
<h3 id="Terminal使用"><a href="#Terminal使用" class="headerlink" title="Terminal使用"></a>Terminal使用</h3><p>修改变量<code>http_proxy</code>和<code>https_proxy</code>即可,如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export http_proxy=&apos;http://localhost:8087&apos;                                                    </div><div class="line">export https_proxy=&apos;http://localhost:8087&apos;</div></pre></td></tr></table></figure>
<p>总之,在Terminal下,代理后速度比不用代理要<strong>快了</strong>几倍,还是很可以的.</p>
<p>此外,还可以设置git代理, clone不再慢~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global http.proxy &apos;http://127.0.0.1:8087&apos;</div><div class="line">git config --global https.proxy &apos;http://127.0.0.1:8087&apos;</div></pre></td></tr></table></figure></p>
<p>在用<code>wget</code>下载时需要添加<code>--no-check-certificate</code>,否则会<br><code>ERROR: cannot verify github.com&#39;s certificate, issued by ‘CN=GoAgent,OU=GoAgent,O=GoAgent,L=Cernet,ST=Internet,C=CN’:
  Unable to locally verify the issuer&#39;s authority.</code>   </p>
<p>  之后找到解决办法再来更新</p>
<p>其他app也是可以,像迅雷,百度云,spotify这些,很省流量啊</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ipv6&quot;&gt;&lt;a href=&quot;#ipv6&quot; class=&quot;headerlink&quot; title=&quot;ipv6&quot;&gt;&lt;/a&gt;ipv6&lt;/h2&gt;&lt;p&gt;If you ask Google “What is ipv6 ?”, the first entry it will di
    
    </summary>
    
      <category term="Mac配置" scheme="http://wongchen.github.io/categories/Mac%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="IPv6" scheme="http://wongchen.github.io/tags/IPv6/"/>
    
      <category term="GAE" scheme="http://wongchen.github.io/tags/GAE/"/>
    
  </entry>
  
  <entry>
    <title>我的Vim配置</title>
    <link href="http://wongchen.github.io/2016/11/13/%E6%88%91%E7%9A%84MacVim%E9%85%8D%E7%BD%AE/"/>
    <id>http://wongchen.github.io/2016/11/13/我的MacVim配置/</id>
    <published>2016-11-13T05:14:35.000Z</published>
    <updated>2017-08-25T16:23:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>网上关于Vim配置的讲很多，一键配置也很多。但是我们使用Vim不是因为它的插件实现的功能，自动补全，提示有多厉害，而是它自身的逻辑，自身的快速定位，格式化代码。</p>
<p>所以自己使用方便，好用的配置才是最好的！</p>
<p>我起初就是写<code>python</code>，所以主要配置围绕<code>python</code>。首先，在<code>~</code>目录新建<code>.vimrc</code>文件，添加一些配置：</p>
<p><a href="https://github.com/WongChen/.vim/blob/master/.vimrc" target="_blank" rel="external">vimrc</a>文件在这.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div></pre></td><td class="code"><pre><div class="line">&quot;去掉vi的一致性</div><div class="line">set nocompatible</div><div class="line">&quot;文件类型</div><div class="line">filetype on</div><div class="line">自动补全</div><div class="line">set autoindent</div><div class="line">智能补全</div><div class="line">set smartindent</div><div class="line">&quot;显示行号</div><div class="line">set nu!</div><div class="line">&quot;高亮搜索</div><div class="line">set hlsearch</div><div class="line">&quot; 相对行</div><div class="line">set relativenumber</div><div class="line"></div><div class="line">&quot; tab size</div><div class="line">set tabstop=4</div><div class="line">&quot;不折叠</div><div class="line">set unwrap</div><div class="line">&quot;指示当前行</div><div class="line">set cursorline</div><div class="line">&quot;指示当前列</div><div class="line">set cursorcolumn</div><div class="line">&quot;语法</div><div class="line">syntax enable</div><div class="line">&quot;根据文件类型缩进</div><div class="line">filetype indent on</div><div class="line"></div><div class="line">syntax on</div><div class="line">&quot;python 缩进4</div><div class="line">au FileType python set cindent shiftwidth=4</div><div class="line"></div><div class="line">&quot; 绑定jk为ESC按键,操作更方便</div><div class="line">inoremap jk &lt;ESC&gt;</div><div class="line">&quot; 设置Control a左删除, Control d又删除</div><div class="line">inoremap &lt;C-a&gt; &lt;backspace&gt;</div><div class="line">inoremap &lt;C-d&gt; &lt;Right&gt;&lt;backspace&gt;</div><div class="line"></div><div class="line">&quot; 回车 visual line mode</div><div class="line">map &lt;CR&gt; &lt;S-v&gt;</div><div class="line">`</div><div class="line">&quot; 设置 leader key 为空格键</div><div class="line">let mapleader = &quot;\&lt;Space&gt;&quot;</div><div class="line"></div><div class="line">&quot;设置在插入模式下, xz为下行输入, zx为上行输入</div><div class="line">imap xz &lt;ESC&gt;o</div><div class="line">imap zx &lt;Up&gt;&lt;ESC&gt;o</div><div class="line"></div><div class="line">&quot;结合leader key设置  空格加w 保存, 空格加zz 保存退出,也是为了快捷操作&quot;</div><div class="line">nnoremap &lt;Leader&gt;zz :wq&lt;CR&gt;</div><div class="line">nnoremap &lt;Leader&gt;w :w&lt;CR&gt;</div></pre></td></tr></table></figure>
<p>之后安装插件:</p>
<h2 id="vundle插件管理工具"><a href="#vundle插件管理工具" class="headerlink" title="vundle插件管理工具"></a>vundle插件管理工具</h2><ul>
<li>安装</li>
</ul>
<p><code>git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle</code></p>
<ul>
<li>配置</li>
</ul>
<p>在<code>.vimrc</code>中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set rtp+=~/.vim/bundle/vundle/</div><div class="line">call vundle#rc()</div></pre></td></tr></table></figure>
<ul>
<li>插件安装</li>
</ul>
<p>目前我用的插件,之后再更新.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&quot;目前我使用的插件</div><div class="line"></div><div class="line">Bundle &apos;gmarik/vundle&apos;</div><div class="line"></div><div class="line">Bundle &apos;davidhalter/jedi&apos;</div><div class="line"></div><div class="line">Bundle &apos;Valloric/YouCompleteMe&apos;</div><div class="line"></div><div class="line">Bundle &apos;jiangmiao/auto-pairs&apos;</div><div class="line"></div><div class="line">Bundle &apos;scrooloose/nerdcommenter&apos;</div></pre></td></tr></table></figure>
<p>安装插件,只需在任一vim窗口<code>normal</code>模式下执行<code>BundleInstall</code>即可.</p>
<h2 id="jedi"><a href="#jedi" class="headerlink" title="jedi"></a>jedi</h2><p>Python补全强力插件.</p>
<h3 id="YouCompleteMe"><a href="#YouCompleteMe" class="headerlink" title="YouCompleteMe"></a>YouCompleteMe</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><blockquote>
<p><a href="http://valloric.github.io/YouCompleteMe/#intro" target="_blank" rel="external">YouCompleteMe</a> is a fast, as-you-type, fuzzy-search code completion engine for Vim.</p>
</blockquote>
<p>特点:</p>
<ul>
<li>识别every language</li>
<li>支持C-family languages(C/C++/Objective-C/Objective-C++)</li>
<li>对于Python2/3附带Jedi-based补全(尴尬,另外的jedi卸载了也没关系),使用jediHttp wrapper</li>
<li>an OmniSharp-based completion engine for C#(不懂C#)</li>
<li>a Tern-based completion engine for JavaScript</li>
<li>…</li>
</ul>
<p>此外还有<a href="a Tern-based completion engine for JavaScript">semantic IDE-like features</a>,像goto declarations, definitions, usages, etc这种,根据语意重命名变量(rename variables)等等,使用体验试试吧</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li>使用mvim(Vim binary that is inside the MacVim.app package )更好体验,将vim链接到mvim</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s /usr/local/bin/mvim vim</div></pre></td></tr></table></figure>
<ul>
<li>vundle cloneYCM后,到YCM目录编译,需要用到<a href="https://cmake.org/download/" target="_blank" rel="external">Cmake</a></li>
<li>编译</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/.vim/bundle/YouCompleteMe</div><div class="line">./install.py --[xxx]</div></pre></td></tr></table></figure>
<p>可选参数有:</p>
<ul>
<li>–clang-completer,添加C-family支持</li>
<li>–all, everything</li>
</ul>
<h3 id="auto-pairs"><a href="#auto-pairs" class="headerlink" title="auto-pairs"></a>auto-pairs</h3><p>添加引号,括号配对补全,不多说了.</p>
<h2 id="nerdcommenter"><a href="#nerdcommenter" class="headerlink" title="nerdcommenter"></a>nerdcommenter</h2><p>添加/解除注释,支持多种语言,默认操作为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;leader&gt;cc   加注释</div><div class="line">&lt;leader&gt;cu   解开注释</div></pre></td></tr></table></figure>
<h2 id="vim学习"><a href="#vim学习" class="headerlink" title="vim学习"></a>vim学习</h2><ul>
<li><code>vimtutor</code>是最基础的老师了.</li>
<li>在推荐一个<a href="https://getpocket.com/a/read/43816131" target="_blank" rel="external">vim 学习的链接</a>,看完这个应该能学到好多</li>
<li>话说新MacBook Pro with TouchBar取消了<code>esc</code>键后,vim使用便比较尴尬</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inoremap jk &lt;ESC&gt;</div></pre></td></tr></table></figure>
<p>环境搭建好之后,强迫自己多使用学习到的vim高端操作,逐渐熟悉,尤其是在远程CLI环境中,vim很有用,慢慢你会熟悉掌握并爱上vim.</p>
<p>映射到自己喜欢的按键吧.<br>等等.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上关于Vim配置的讲很多，一键配置也很多。但是我们使用Vim不是因为它的插件实现的功能，自动补全，提示有多厉害，而是它自身的逻辑，自身的快速定位，格式化代码。&lt;/p&gt;
&lt;p&gt;所以自己使用方便，好用的配置才是最好的！&lt;/p&gt;
&lt;p&gt;我起初就是写&lt;code&gt;python&lt;/c
    
    </summary>
    
      <category term="Mac配置" scheme="http://wongchen.github.io/categories/Mac%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="mac" scheme="http://wongchen.github.io/tags/mac/"/>
    
      <category term="vim" scheme="http://wongchen.github.io/tags/vim/"/>
    
  </entry>
  
</feed>
