<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>印第安老斑鸠</title>
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://wongchen.github.io/"/>
  <updated>2017-08-23T14:48:23.000Z</updated>
  <id>http://wongchen.github.io/</id>
  
  <author>
    <name>Wong Chen</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python之generator学习</title>
    <link href="http://wongchen.github.io/2017/08/20/python-generator/"/>
    <id>http://wongchen.github.io/2017/08/20/python-generator/</id>
    <published>2017-08-19T16:43:18.000Z</published>
    <updated>2017-08-23T14:48:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>先看一个问题: 假设我们遇到一个需要长时间响应才能得到返回值的情境,比如深度学习中的大计算或者网络较长时间的响应等(这里我们用<code>sleep()</code>函数来代替),每次需要较长时间的计算才能得到结果.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_compute</span><span class="params">()</span>:</span></div><div class="line">  rv = list()</div><div class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    sleep(<span class="number">2</span>)</div><div class="line">    rv.append(i)</div><div class="line">  <span class="keyword">return</span> rv</div></pre></td></tr></table></figure>
<p>如上面所述,假如我想得到的最终结果含10个值,我需要20秒才能观察到最后结果,但是假如包含更长的值(如100呢)而且我想观察前几个值呢? 因为从前几个值就能发现一些有意义的东西,我不需要观察全部的值就能得到我想要的,怎么办?</p>
<p>明显要等到全部值计算完都返回是不符合逻辑的,如果我们只是观察结果不用到返回值的情况可以每次都<code>print</code>打印出每次的结果,但是这也不能解决所有的情况. 幸运的是我们可以通过<code>generator</code>来解决这种问题.</p>
<h2 id="What-is-python-Generator"><a href="#What-is-python-Generator" class="headerlink" title="What is python Generator?"></a>What is python Generator?</h2><blockquote>
<p>Introduced in Python 2.2 as an optional feature and finalized in version 2.3, <a href="https://en.wikipedia.org/wiki/Generator_(computer_science" target="_blank" rel="external">generators</a>) are Python’s mechanism for <a href="https://en.wikipedia.org/wiki/Lazy_evaluation" target="_blank" rel="external">lazy evaluation</a> of a function that would otherwise return a space-prohibitive or computationally intensive list.</p>
<p>A Python <em>generator</em> is a function which returns a <em>generator iterator</em> (just an object we can iterate over) by calling <code>yield</code>. <code>yield</code> may be called with a value, in which case that value is treated as the “generated” value. The <em>next time</em><code>next()</code> is called on the <em>generator iterator</em> (i.e. in the next step in a <code>for</code> loop, for example),the generator resumes execution <em>from where it called yield</em>, not from the beginning of the function. All of the state, like the values of local variables, is recovered and the generator contiues to execute until the next call to <code>yield</code>.</p>
</blockquote>
<p>generator可以不像一般的函数那样,一次返回一个值,下一次还在上次执行的地方继续运行程序返回下一个值,可以说是返回一系列值(One at a time). </p>
<h3 id="Generator-expressions"><a href="#Generator-expressions" class="headerlink" title="Generator expressions"></a>Generator expressions</h3><blockquote>
<p>Introduced in Python 2.4, generator expressions are the lazy evaluation equivalent of list comprehensions. </p>
</blockquote>
<p>不同于生成器,生成器表达式是<code>list comprehensions</code>的generator形式表达.与<code>list comprehensions</code>长得很像,但是返回一个generator而不是list.</p>
<p>此外,generator不能用下标来索引.</p>
<p>如下, 详细后面叙述.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">&gt;&gt;&gt; a = (x for x in range(8))</div><div class="line">&gt;&gt;&gt; a</div><div class="line">&lt;generator object &lt;genexpr&gt; at 0x104684960&gt;</div><div class="line">&gt;&gt;&gt; a[2]</div><div class="line">Traceback (most recent call last):</div><div class="line">  File &quot;&lt;stdin&gt;&quot;, line 1, in &lt;module&gt;</div><div class="line">TypeError: &apos;generator&apos; object has no attribute &apos;__getitem__&apos;</div></pre></td></tr></table></figure>
<h2 id="如何"><a href="#如何" class="headerlink" title="如何"></a>如何</h2><p>对于开始提出的问题,如何使用generator来解决呢?</p>
<p>我们最后想要的是一个可以迭代的对象,大致为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">x = iter(rv)</div><div class="line">next_value = next(x)</div></pre></td></tr></table></figure>
<p>我们知道python中许多方法和属性都是有对应的double underscore属性和方法的(如<code>__add__</code>).上面的对应为<code>__iter__</code>(python2中是<code>next()</code>)和<code>__next__</code>方法.</p>
<p>于是我们可以使用一个类,实现上述两种方法来实现generator.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ComputerLong</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__iter__</span><span class="params">(self)</span>:</span></div><div class="line">    self.last = <span class="number">0</span></div><div class="line">    <span class="keyword">return</span> self</div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">__next__</span><span class="params">(self)</span>:</span></div><div class="line">    rv = self.last</div><div class="line">    self.last += <span class="number">1</span></div><div class="line">    <span class="keyword">if</span> self.last &gt; <span class="number">10</span>:</div><div class="line">      <span class="keyword">raise</span> StopIteration()</div><div class="line">    sleep(<span class="number">2</span>)</div><div class="line">    <span class="keyword">return</span> rv</div></pre></td></tr></table></figure>
<p>但是这样读起来太费劲了,正常点的写法还是应该像上面函数那样. 更Generator的写法应该使用<code>yield</code>.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">long_time_compute</span><span class="params">()</span>:</span></div><div class="line">  rv = list()</div><div class="line">  <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</div><div class="line">    sleep(<span class="number">2</span>)</div><div class="line">    <span class="keyword">yield</span> i</div><div class="line"> <span class="comment">#   rv.append(i)</span></div><div class="line"> <span class="comment"># return rv</span></div></pre></td></tr></table></figure>
<p>Generator每次生成一个新的值时,采用<code>yield</code>关键字代替原来return的位置,相当于返回一个需要即可取的值.</p>
<p>Generator返回是一个可迭代的对象,因此可以使用<code>for</code>循环:</p>
<p>每次<code>for</code>循环中需要一个值时,便会调用generator对象的next()方法,取回一个值.</p>
<h2 id="generator结束"><a href="#generator结束" class="headerlink" title="generator结束"></a>generator结束</h2><p>当generator函数中使用return或者generator迭代到最后,将会返回一个<code>StopIteration</code> exception,当next到最后一个值时将会报错,因此generator只能够循环一次.</p>
<p><img src="images/Screenshot2017-08-23_下午10.27.24.png" alt=""></p>
<p>最后:</p>
<ul>
<li>generator可以用来返回一个迭代器,可以返回一个序列(每次一个值而不是直接全部的返回值).</li>
<li>yield可以看做next()方法return一个值并记住这个位置,下次在这个位置利用next()方法仍旧如此.</li>
<li>python2中generator next()方法为<code>g.next()</code>,而python3为<code>g.__next__()</code></li>
</ul>
<p>s</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;动机&quot;&gt;&lt;a href=&quot;#动机&quot; class=&quot;headerlink&quot; title=&quot;动机&quot;&gt;&lt;/a&gt;动机&lt;/h2&gt;&lt;p&gt;先看一个问题: 假设我们遇到一个需要长时间响应才能得到返回值的情境,比如深度学习中的大计算或者网络较长时间的响应等(这里我们用&lt;code&gt;s
    
    </summary>
    
      <category term="python" scheme="http://wongchen.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://wongchen.github.io/tags/python/"/>
    
      <category term="generator" scheme="http://wongchen.github.io/tags/generator/"/>
    
  </entry>
  
  <entry>
    <title>学习python中的Decorator</title>
    <link href="http://wongchen.github.io/2017/08/19/python-decorator/"/>
    <id>http://wongchen.github.io/2017/08/19/python-decorator/</id>
    <published>2017-08-19T12:28:27.000Z</published>
    <updated>2017-08-23T13:10:37.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="What-is-a-Decorator"><a href="#What-is-a-Decorator" class="headerlink" title="What is a Decorator?"></a>What is a Decorator?</h2><p>参考<a href="https://en.wikipedia.org/wiki/Decorator_pattern" target="_blank" rel="external">Decorator Pattern wiki</a>,(这个维基词条多讲得是Java/C#/C++相关,但是与python中的实现的功能类似.)</p>
<blockquote>
<p>A decorator is the name used for a software design pattern. Decorators dynamically alter the functionality of a function, method, or class without having to directly use subclasses or change the source code of the function being decorated.</p>
<p><strong>修饰模式</strong>，是<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B" target="_blank" rel="external">面向对象编程</a>领域中，一种动态地往一个类中添加新的行为的<a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F" target="_blank" rel="external">设计模式</a>。就功能而言，修饰模式相比生成<a href="https://zh.wikipedia.org/wiki/%E5%AD%90%E7%B1%BB" target="_blank" rel="external">子类</a>更为灵活，这样可以给某个对象而不是整个类添加一些功能。</p>
<p>通过使用修饰模式，可以在运行时扩充一个类的功能。原理是：增加一个修饰类包裹原来的类，包裹的方式一般是通过在将原来的对象作为修饰类的构造函数的参数。装饰类实现新的功能，但是，在不需要用到新功能的地方，它可以直接调用原来的类中的方法。修饰类必须和原来的类有相同的接口。</p>
</blockquote>
<p><a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators" target="_blank" rel="external">Python Decorator</a>:</p>
<blockquote>
<p>A decorator is any callable Python object that is used to modify a function, method or class definition. A decorator is passed the original object being defined and returns a modified object, which is then bound to the name in the definition. Python decorators were inspired in part by <a href="https://en.wikipedia.org/wiki/Java_annotation" target="_blank" rel="external">Java annotations</a>, and have a similar syntax; the decorator syntax is pure <a href="https://en.wikipedia.org/wiki/Syntactic_sugar" target="_blank" rel="external">syntactic sugar</a>, using <code>@</code> as the keyword:</p>
</blockquote>
<p>在python中,Decorator与<a href="https://en.wikipedia.org/wiki/Functional_programming" target="_blank" rel="external">函数式编程(Functional Programming)</a>和<a href="https://en.wikipedia.org/wiki/Metaprogramming" target="_blank" rel="external">元编程(Metaprogramming)</a>息息相关,可以用Decorator来修改一个函数,类以及类的定义.</p>
<h2 id="动机"><a href="#动机" class="headerlink" title="动机"></a>动机</h2><p>接下来举几个简单例子说明python中为何要使用Decorator.</p>
<ol>
<li><p>更加简明,易读</p>
<p>如下面两个例子,分别要实现一个classmethod方法和测试函数试行时间的功能,但是函数的定义和最后要实现的功能处出现了分离,对函数的操作变换代码出现在了函数的后面位置,不管是代码复杂性和逻辑都有问题.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</div><div class="line"><span class="comment"># example 1: a classmethod function</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(self)</span>:</span></div><div class="line">	do_something</div><div class="line">foo = classmethod(foo)</div><div class="line"></div><div class="line"><span class="comment"># example 2: timer for a function</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">	do_something</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">decor_fun</span><span class="params">()</span>:</span></div><div class="line">		start_time = time()</div><div class="line">		func()</div><div class="line">		print(<span class="string">"Cost time: "</span>, time()-start_time)</div><div class="line">	<span class="keyword">return</span> decor_fun</div><div class="line">foo = timer(foo)</div></pre></td></tr></table></figure>
<p>通过Decorator更加直观,明了</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</div><div class="line"><span class="comment"># example 1</span></div><div class="line"><span class="meta">@classmethod</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(cls)</span>:</span></div><div class="line">  do_something</div><div class="line">  </div><div class="line"><span class="comment"># example 2</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func)</span>:</span></div><div class="line">	<span class="function"><span class="keyword">def</span> <span class="title">decor_fun</span><span class="params">()</span>:</span></div><div class="line">		start_time = time()</div><div class="line">		func()</div><div class="line">		print(<span class="string">"Cost time: "</span>, time()-start_time)</div><div class="line">	<span class="keyword">return</span> decor_fun</div><div class="line">  </div><div class="line"><span class="meta">@timer</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">  do_something</div></pre></td></tr></table></figure>
</li>
<li><p>实现特定的功能</p>
<p>参考<a href="https://www.zhihu.com/question/20021164" target="_blank" rel="external">这个知乎问题:Python 中的 classmethod 和 staticmethod 有什么具体用途?</a>,还可以结合函数式编程,某个函数功能需要被其他多个函数重复实现时,可以考虑Decorator,如: example 2测试函数运行时间, 输出log日志等等.</p>
</li>
</ol>
<h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>通过example 2以及<a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Decorators" target="_blank" rel="external">python Decorator Wiki</a>不难看出<code>@</code>符号其实是以要定义的函数<code>foo</code>作为参数传入<code>@</code>后面的函数<code>bar</code>中,返回一个新的同时实现两者功能的函数.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@bar</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">  <span class="keyword">return</span> <span class="string">"foo"</span></div><div class="line"></div><div class="line"><span class="comment"># 等价于以下的  bar(foo)</span></div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">()</span>:</span></div><div class="line">  print(<span class="string">"foo"</span>)</div><div class="line">  </div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">(func)</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">func_decor</span><span class="params">()</span>:</span></div><div class="line">    print(<span class="string">"bar/"</span>+func())  </div><div class="line">  <span class="keyword">return</span> func_decor</div></pre></td></tr></table></figure>
<h3 id="带参数呢"><a href="#带参数呢" class="headerlink" title="带参数呢?"></a>带参数呢?</h3><p>如果接触过函数式编程的话,不难解决这个问题,更普遍的方法可以使用<code>*args</code>和<code>**kwargs</code>关键字,针对带有默认参数和不带有默认参数的函数都可以解决.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> time <span class="keyword">import</span> time</div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">timer</span><span class="params">(func, *args, **kwargs)</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">decor_func</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">    start_time = time()</div><div class="line">    ans = func(*args, **kwargs)</div><div class="line">    print(<span class="string">"cost time: "</span>, time()-start_time)</div><div class="line">    <span class="keyword">return</span> ans</div><div class="line">  <span class="keyword">return</span> decor_func</div><div class="line"></div><div class="line"><span class="meta">@timer</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">add2</span><span class="params">(x, y=<span class="number">66</span>)</span>:</span></div><div class="line">  <span class="keyword">return</span> x + y</div></pre></td></tr></table></figure>
<p>另外,Decorator也是可以输入参数的,还是上一个例子,实现调用n次函数.</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">def ntimes(n):</div><div class="line">  def innner(func)</div><div class="line">  	def wrapper(*args, **kwargs):</div><div class="line">	  for _ in range(n):</div><div class="line">        print("calling function %s"%func.__name__)</div><div class="line">        ans = func(*args, **kwargs)</div><div class="line">      return ans</div><div class="line">    return wrapper</div><div class="line">  return inner</div><div class="line">n = 10</div><div class="line">@ntimes(10)</div><div class="line">def add2(x, y=66):</div><div class="line">  return x + y</div></pre></td></tr></table></figure>
<p>本例中,从函数式编程角度看,深度更深了一层,从<code>@</code>本质理解,其后符号ntimes也是函数,故也可接受参数,一般Decorator不会比这个更深,所以了解即可. 详情可以了解<a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#Closures" target="_blank" rel="external">python中的闭包</a>.</p>
<h3 id="多个Decorator"><a href="#多个Decorator" class="headerlink" title="多个Decorator"></a>多个Decorator</h3><p>道理都是类似的,语法为</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">@dec2</span></div><div class="line"><span class="meta">@dec1</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(arg1, arg2, ...)</span>:</span></div><div class="line">    <span class="keyword">pass</span></div></pre></td></tr></table></figure>
<h2 id="Class-Decorator"><a href="#Class-Decorator" class="headerlink" title="Class Decorator"></a>Class Decorator</h2><blockquote>
<p>In Python prior to version 2.6, decorators apply to functions and methods, but not to classes. Decorating a (dummy) <code>__new__</code> method can modify a class, however.<a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#cite_note-28" target="_blank" rel="external">[25]</a>Class decorators are supported<a href="https://en.wikipedia.org/wiki/Python_syntax_and_semantics#cite_note-29" target="_blank" rel="external">[26]</a> starting with Python 2.6.</p>
</blockquote>
<p>Python 2.6之后才支持class decorators,之前都是通过metaclass来实现相应功能,<code>__new__</code>方法修改类.</p>
<p>按照之前的解释,Class Decorator与Function Decorator应该是基本相同的,只是装饰的对象不同而已.</p>
<h3 id="Decorator-作用整个类"><a href="#Decorator-作用整个类" class="headerlink" title="Decorator 作用整个类"></a>Decorator 作用整个类</h3><p>可以看到此时的decorator接受一个类作为函数参数,返回一个修饰之后的类,跟之前一样的道理.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator</span><span class="params">(cls)</span>:</span></div><div class="line">    <span class="class"><span class="keyword">class</span> <span class="title">Wrapper</span><span class="params">(object)</span>:</span></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, *args)</span>:</span></div><div class="line">            self.wrapped = cls(*args)</div><div class="line"></div><div class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__getattr__</span><span class="params">(self, name)</span>:</span></div><div class="line">            print(<span class="string">'Getting the &#123;&#125; of &#123;&#125;'</span>.format(name, self.wrapped))</div><div class="line">            <span class="keyword">return</span> getattr(self.wrapped, name)</div><div class="line"></div><div class="line">    <span class="keyword">return</span> Wrapper</div><div class="line"></div><div class="line"><span class="meta">@decorator</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, x, y)</span>:</span></div><div class="line">        self.x = x</div><div class="line">        self.y = y</div></pre></td></tr></table></figure>
<h3 id="Decorator本身是类"><a href="#Decorator本身是类" class="headerlink" title="Decorator本身是类"></a>Decorator本身是类</h3><p>如下面例子所示,</p>
<p><code>__init__</code>方法接受要修饰的函数为参数.</p>
<p><code>__call__</code>方法在调用被修饰函数时调用.</p>
<p>此外还有<code>__set__</code>, <code>__get__</code>, <code>__getattribute__</code>等方法均可修改.    </p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">decorator</span><span class="params">(object)</span>:</span></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, func)</span>:</span></div><div class="line">        self.func = func</div><div class="line"></div><div class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, *args)</span>:</span></div><div class="line">        print(<span class="string">'Called &#123;func&#125; with args: &#123;args&#125;'</span>.format(func=self.func.func_name,</div><div class="line">                                                       args=args))</div><div class="line">        <span class="keyword">return</span> self.func(*args)</div><div class="line"></div><div class="line"><span class="meta">@decorator</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">(x,y)</span>:</span></div><div class="line">    <span class="keyword">return</span> x + y</div><div class="line"></div><div class="line">func(<span class="number">1</span>, <span class="number">3</span>)</div></pre></td></tr></table></figure>
<p>从这个角度看,Decorator可以实现修改调用模型的这一功能. 可以参考<a href="https://www.ibm.com/developerworks/cn/linux/l-cpdecor.html" target="_blank" rel="external">修改调用模型</a>.</p>
<h2 id="改进"><a href="#改进" class="headerlink" title="改进"></a>改进</h2><p>仔细研读细节就会发现,使用decorator可以完成期望的功能,取得成效,但是也会带来代码细节与原本出现偏差的问题,毕竟对了一层调用,改进方法可以使用 <code>functools</code>的<code>wraps</code>Decorator.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_decorator</span><span class="params">(func)</span>:</span></div><div class="line"><span class="meta">  @wraps(f)</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">    func(*args, **kwargs)</div><div class="line">  <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure>
<p>也可以使用decorator.</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">from</span> decorator <span class="keyword">import</span> decorator</div><div class="line"></div><div class="line"><span class="meta">@decorator	</span></div><div class="line"><span class="function"><span class="keyword">def</span> <span class="title">some_decorator</span><span class="params">(func)</span>:</span></div><div class="line">  <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args, **kwargs)</span>:</span></div><div class="line">    func(*args, **kwargs)</div><div class="line">  <span class="keyword">return</span> wrapper</div></pre></td></tr></table></figure>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;What-is-a-Decorator&quot;&gt;&lt;a href=&quot;#What-is-a-Decorator&quot; class=&quot;headerlink&quot; title=&quot;What is a Decorator?&quot;&gt;&lt;/a&gt;What is a Decorator?&lt;/h2&gt;&lt;p&gt;
    
    </summary>
    
      <category term="python" scheme="http://wongchen.github.io/categories/python/"/>
    
    
      <category term="python" scheme="http://wongchen.github.io/tags/python/"/>
    
      <category term="decorator" scheme="http://wongchen.github.io/tags/decorator/"/>
    
  </entry>
  
  <entry>
    <title>我的KeyboardMaestro宏</title>
    <link href="http://wongchen.github.io/2016/12/09/myKeyboardMaestroActions/"/>
    <id>http://wongchen.github.io/2016/12/09/myKeyboardMaestroActions/</id>
    <published>2016-12-09T08:16:00.000Z</published>
    <updated>2017-08-08T15:27:41.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.keyboardmaestro.com/main/" target="_blank" rel="external">Keyboard Maestro</a>作为Mac下出名的效率软件,有着不菲的名声,是<strong>Winner of a Macworld Editors’ Choice Award for 2013.</strong></p>
<p>官网的介绍是:</p>
<blockquote>
<p>Whether you are a power user or a grandparent (or both!), your time is precious. So why waste it when Keyboard Maestro can help improve almost every aspect of using your Mac. Even the simplest things, like typing your email address, or going to Gmail or Facebook, launching Pages, or duplicating a line, all take time and add frustration. <strong>Let Keyboard Maestro help make your Mac life more pleasant and efficient.</strong></p>
</blockquote>
<p>工欲善其事必先利其器,在使用Mac工作学习的过程中发现一些跟之前使用习惯不适应和”稍微反人类的”一些操作,比如在Finder中的<em>“在当前目录打开终端”</em>等操作,因此想到了Keyboard Maestro,通过它来简化一些操作将大大提高效率,也更加简便.</p>
<p>然后在这里简单介绍我常用的一些宏(<strong>常更新哦</strong>)</p>
<h2 id="Finder"><a href="#Finder" class="headerlink" title="Finder"></a>Finder</h2><p>Finder作为使用率最高的软件之一,首先介绍Finder相关的宏.由于快捷键太难记忆而决定采用Palette,Finder不会占据太大的空间,因此Palette也不会出现遮挡Finder窗口的问题.</p>
<p><img src="/images/palette.png" alt="finder palette"></p>
<p>显示为</p>
<p><img src="/images/finder_palette.png" alt="finder palette display"></p>
<ul>
<li>在Finder中显示”在terminal中打开”,很简单如下图实现</li>
</ul>
<p><img src="/images/finder_terminal.png" alt="finder terminal"></p>
<ul>
<li>新建文件(<strong>文件名自行输入</strong>)</li>
</ul>
<p>由于Keyboard Maestro支持Apple Script,因此可以通过如下代码实现:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">tell application &quot;Finder&quot;</div><div class="line">	set annoying_path to the target of the front window as text</div><div class="line">	set actual_path to POSIX path of annoying_path</div><div class="line">	set something to display dialog &quot;File name?&quot; default answer &quot;&quot;</div><div class="line">	set textReturned to text returned of something</div><div class="line">	set newFileName to actual_path &amp; textReturned</div><div class="line">	set accessNum to open for access newFileName with write permission</div><div class="line">end tell</div></pre></td></tr></table></figure>
<p>点击<code>&quot;新建文件&quot;</code>时,会提示窗口输入文件名</p>
<p><img src="/images/fider_new_file.png" alt="new file"></p>
<ul>
<li>复制文件名</li>
</ul>
<p>只需如下脚本:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tell application &quot;Finder&quot;</div><div class="line">	set theFile to the selection</div><div class="line">	set fileName to name of item 1 of theFile</div><div class="line">	set the clipboard to fileName</div><div class="line">end tell</div></pre></td></tr></table></figure>
<p>另外Mac自带的<strong>脚本编辑器</strong>,可以编写运行Apple Script,在写脚本时可以用它写完测试ok后再复制到Keyboard Maestro中.</p>
<ul>
<li>复制文件绝对路径</li>
</ul>
<p>有时在终端下工作时,或者其他环境中需要某一文件的路径,这时候使用绝对路径会是有效可靠且方便的,同样脚本为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">tell application &quot;Finder&quot;</div><div class="line">	set sel to the selection</div><div class="line">	set the clipboard to POSIX path of (sel as text)</div><div class="line">end tell</div></pre></td></tr></table></figure>
<p>结合Apple Script, Keyboard Maestro可以发挥更加强大的功能,慢慢通过不断的需求和学习可以开发出更多新的功能</p>
<h2 id="Launch-Apps"><a href="#Launch-Apps" class="headerlink" title="Launch Apps"></a>Launch Apps</h2><p>对于一些常用的应用程序可以设定某些快捷键,方便快速启动,就像在Linux下面,<code>Alt</code> <code>+</code> <code>control</code> <code>+</code>  <code>T</code> 开启终端,win下面, <code>win</code> <code>+</code> <code>D</code>开启文件管理器.</p>
<p>我常用的如:</p>
<p><img src="/images/launch_app_lists.png" alt="launch apps"></p>
<p>设定自己习惯,容易记忆的快捷键即可.</p>
<p>另外,发现每次截图之后想要寻找截图照片变得繁杂,因此每次截图后主动在Finder下显示截图目录</p>
<p><img src="/images/screeshots_finder.png" alt="截图 弹窗"></p>
<p>(逐渐更新中….)</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.keyboardmaestro.com/main/&quot; target=&quot;_blank&quot; rel=&quot;external&quot;&gt;Keyboard Maestro&lt;/a&gt;作为Mac下出名的效率软件,有着不菲的名声,是&lt;strong&gt;Winner 
    
    </summary>
    
      <category term="Mac配置" scheme="http://wongchen.github.io/categories/Mac%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="Keyboard Maestro" scheme="http://wongchen.github.io/tags/Keyboard-Maestro/"/>
    
  </entry>
  
  <entry>
    <title>Mac下安装软件包遇到的错误总结</title>
    <link href="http://wongchen.github.io/2016/11/22/mac-uninstall-pip-packages/"/>
    <id>http://wongchen.github.io/2016/11/22/mac-uninstall-pip-packages/</id>
    <published>2016-11-21T16:30:37.000Z</published>
    <updated>2017-08-08T14:23:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>最近在装一些软件包的时候,总遇到一些很难解决的错误,总结下:</p>
<h2 id="scipy-seaborn"><a href="#scipy-seaborn" class="headerlink" title="scipy, seaborn"></a>scipy, seaborn</h2><p>Python的包我都是采用pip来安装的</p>
<blockquote>
<p>SciPy (pronounced “Sigh Pie”) is a Python-based ecosystem of open-source software for mathematics, science, and engineering. In particular, these are some of the core packages:</p>
</blockquote>
<ul>
<li>NumPy</li>
<li>SciPy</li>
<li>Matplotlib</li>
<li>IPython</li>
<li>Sympy</li>
<li>pandas</li>
</ul>
<p>Seaborn的话,</p>
<blockquote>
<p>Seaborn is a Python visualization library based on matplotlib. It provides a high-level interface for drawing attractive statistical graphics.</p>
</blockquote>
<p>但是,我用<code>pip install seaborn</code>后,import时,出现<font color="red">ERROR</font></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">from . import futil</div><div class="line">ImportError: cannot import name futil</div></pre></td></tr></table></figure>
<p>在这之前还有个错误,这个跟个人习惯有关,我在本地创建的一个<code>new.py</code>的文件,正好seaborn导入时会用到<code>new.py</code>,由Python包导入顺序此时本地的<code>new</code>要优先于seaborn的<code>new</code>,这个”案子”提示我们自我创建文件时</p>
<ol>
<li>目录要准确</li>
<li>名字不要太容易起冲突</li>
</ol>
<p>不过这类错误一眼也能看出来.<br>回到刚那个错误,搜索很久,发现安装的<code>SciPy</code>应该是一个Broken的版本(到那个目录查看的话,会发现<code>futil.so</code>这个文件),更新下就好了.然而,这货根本卸载不掉</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">OSError: [Errno 1] Operation not permitted: &apos;/tmp/pip-JPaA5b-uninstall/System/Library/Frameworks/Python.framework/Versions/2.7/Extras/lib/python/scipy-0.13.0b1-py2.7.egg-info&apos;</div></pre></td></tr></table></figure>
<p>参考<a href="http://xiaorui.cc/2016/03/27/%E8%A7%A3%E5%86%B3mac-osx%E4%B8%8Bpip%E5%AE%89%E8%A3%85ipython%E6%9D%83%E9%99%90%E7%9A%84%E9%97%AE%E9%A2%98/" target="_blank" rel="external">解决mac osx下pip安装ipython权限的问题</a>,终于解决了.</p>
<blockquote>
<p>由于El Capitan引入了SIP机制(System Integrity Protection),默认下系统启用SIP系统完整性保护机制，无论是对于硬盘还是运行时的进程限制对系统目录的写操作。<br>  现在的解决办法是取消SIP机制，具体做法是：<br>重启电脑，按住Command+R(直到出现苹果标志)进入Recovery Mode(恢复模式)<br>左上角菜单里找到实用工具 -&gt; 终端<br>输入csrutil disable回车<br>重启Mac即可<br>如果想重新启动SIP机制重复上述步骤改用csrutil enable即可.</p>
</blockquote>
<p>这下好了,然而运行下面这段代码时发现,</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">sns.set_style(&quot;whitegrid&quot;)</div><div class="line">data = np.random.normal(size=(20, 6)) + np.arange(6) / 2</div><div class="line">sns.boxplot(data=data);</div></pre></td></tr></table></figure>
<p>这根本什么都没有,什么都没有,其实这个问题很早就有了……</p>
<p><a href="https://www.zhihu.com/question/35169072" target="_blank" rel="external">知乎</a><br><a href="http://stackoverflow.com/questions/2512225/matplotlib-not-showing-up-in-mac-osx" target="_blank" rel="external">stack<strong>overflow</strong></a></p>
<p>都这么长时间了,真是的,尝试了下面的所有方法,只有<code>plt.show()</code>这个方法能使.但是,这个”小火箭”,便退不出去了<img src="/images/python_sns.png" alt="python sns"><br>不过<code>sns.plt</code>倒是有很多功能,应该能够实现我们想要的.</p>
<h2 id="VTK"><a href="#VTK" class="headerlink" title="VTK"></a>VTK</h2><p>全称是<strong>The Visulition ToolKit</strong>, 有<a href="http://www.vtk.org/Wiki/Main_Page" target="_blank" rel="external">wiki</a>.</p>
<p>安装完遇到的第一个问题便是几个examples的cxx版本,几乎什么都没有<br><img src="http://g.recordit.co/TWfNFkfk2y.gif" alt="NoneVtk"><br>似乎是VTK版本更新后,出现了这些问题,我不知道了.不过还是有其他例子可以显示的.</p>
<p>有些例子中包含vtkRenderWindowInteractor`即VTK交互渲染窗口是可以正常显示的,但是其他就不行了.</p>
<p>后来发现解决方法:</p>
<p>举例来说,如这个<a href="https://github.com/Kitware/VTK/blob/master/Examples/Tutorial/Step1/Cxx/Cone.cxx" target="_blank" rel="external">例子</a>是VTK官方的Toturial中的step1,在cxx源代码中加入</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">#include &lt;unistd.h&gt;</div><div class="line">// &lt;...step1 code...&gt;</div><div class="line"> for (i = 0; i &lt; 360; ++i) //每次渲染窗口时通过usleep函数,可以让窗口保留显示一段时间</div><div class="line">  &#123;</div><div class="line">    usleep(microseconds);</div><div class="line"></div><div class="line">    // render the image</div><div class="line">    renWin-&gt;Render();</div><div class="line">    // rotate the active camera by one degree</div><div class="line">    ren1-&gt;GetActiveCamera()-&gt;Azimuth( 1 );</div><div class="line">  &#125;</div></pre></td></tr></table></figure>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li>安装MITK时,用Cmake编译好久,错误好多,无法解决</li>
<li>安装Qt5,遇到错误</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Project ERROR: Xcode not set up properly. You may need to confirm the license agreement by running /usr/bin/xcodebuild</div></pre></td></tr></table></figure>
<p>后来发现是个某个版本的bug,换了其他方式安装合适的版本后ok了</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;最近在装一些软件包的时候,总遇到一些很难解决的错误,总结下:&lt;/p&gt;
&lt;h2 id=&quot;scipy-seaborn&quot;&gt;&lt;a href=&quot;#scipy-seaborn&quot; class=&quot;headerlink&quot; title=&quot;scipy, seaborn&quot;&gt;&lt;/a&gt;scipy, s
    
    </summary>
    
      <category term="Mac配置" scheme="http://wongchen.github.io/categories/Mac%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="mac" scheme="http://wongchen.github.io/tags/mac/"/>
    
      <category term="pip" scheme="http://wongchen.github.io/tags/pip/"/>
    
      <category term="vtk" scheme="http://wongchen.github.io/tags/vtk/"/>
    
      <category term="seaborn" scheme="http://wongchen.github.io/tags/seaborn/"/>
    
  </entry>
  
  <entry>
    <title>IPv6环境使用Goagent代理免校园网流量</title>
    <link href="http://wongchen.github.io/2016/11/13/gae-proxy-ipv6/"/>
    <id>http://wongchen.github.io/2016/11/13/gae-proxy-ipv6/</id>
    <published>2016-11-13T14:49:58.000Z</published>
    <updated>2017-03-20T05:22:41.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ipv6"><a href="#ipv6" class="headerlink" title="ipv6"></a>ipv6</h2><p>If you ask Google “What is ipv6 ?”, the first entry it will display says that</p>
<blockquote>
<p>Internet Protocol Version 6 (IPv6) is a network layer protocol that enables data communications over a packet switched network. Packet switching involves the sending and receiving of data in packets between two nodes in a network. </p>
</blockquote>
<p>用中文讲,就是</p>
<blockquote>
<p>互联网通信协议第6版（英文：Internet Protocol version 6，缩写：IPv6）是互联网协议的最新版本，用于分组交换互联网络的网络层协议，旨在解决IPv4地址枯竭问题。<br>  IPv6意图替换IPv4，而IPv4在2014年5月仍然在网络交通上占有96%。[1][2][3]在2014年10月，通过IPv6使用Google服务的用户百分率首次超过5%。</p>
</blockquote>
<p>  教育网由于采用IPv6,有它固有的优势</p>
<ul>
<li>地址容量大大扩展，由原来的32位扩充到128位，彻底解决IPv4地址不足的问题；支持分层地址结构，从而更易于寻址；扩展支持组播和任意播地址，这使得数据包可以发送给任何一个或一组节点；</li>
<li>大容量的地址空间能够真正的实现无状态地址自动配置，使IPv6终端能够快速连接到网络上，无需人工配置，实现了真正的即插即用；</li>
<li>…… 其实我是不懂的</li>
</ul>
<h2 id="GoAgent"><a href="#GoAgent" class="headerlink" title="GoAgent"></a>GoAgent</h2><p>From <a href="https://zh.wikipedia.org/wiki/GoAgent" target="_blank" rel="external">Wikepidia</a>,</p>
<blockquote>
<p>GoAgent是使用跨平台语言Python开发、基于GPL自由软件协议的代理软件。它利用Google App Engine（GAE）的服务器充当代理。从2015年8月以后，GoAgent已停止维护，并被开发者删除。不过，GoAgent作者phuslu于2015年3月开始开发的另一个翻墙软件GoProxy仍处于活跃维护状态。</p>
</blockquote>
<p>虽然那会儿停止维护了,但是我发现虽然IPv4的IP不能使了,IPv6还是OK的.于是我就大部分时间一直都在用它,用到现在.</p>
<p>具体怎么用就不说了,BTW,需要开启IPv6,在<code>local/proxy.ini</code>配置文件中,修改<code>ipv6=1</code><br><img src="/images/ipv6.png" alt="ipv6"></p>
<h3 id="浏览器使用"><a href="#浏览器使用" class="headerlink" title="浏览器使用"></a>浏览器使用</h3><p><code>chrome</code> 配合插件 <code>SwitchyOmega</code>,修改规则<br>代理类型<em>HTTP</em>,服务器 <em>127.0.0.1</em> ,端口 <em>8087</em>,也可以使用备份文件恢复.<br>需要注意的是,完了需要信任其证书.</p>
<p>在线看YouTube还是很快的,经常看Apple/Google 发布会 Live stream,还有NBA 的Live,还有Udacity和Coursera上面的课程……资源还是很多的,速度也基本ok.<br><img src="/images/youtube.png" alt="youtube"></p>
<h3 id="Terminal使用"><a href="#Terminal使用" class="headerlink" title="Terminal使用"></a>Terminal使用</h3><p>修改变量<code>http_proxy</code>和<code>https_proxy</code>即可,如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">export http_proxy=&apos;http://localhost:8087&apos;                                                    </div><div class="line">export https_proxy=&apos;http://localhost:8087&apos;</div></pre></td></tr></table></figure>
<p>总之,在Terminal下,代理后速度比不用代理要<strong>快了</strong>几倍,还是很可以的.</p>
<p>此外,还可以设置git代理, clone不再慢~<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">git config --global http.proxy &apos;http://127.0.0.1:8087&apos;</div><div class="line">git config --global https.proxy &apos;http://127.0.0.1:8087&apos;</div></pre></td></tr></table></figure></p>
<p>在用<code>wget</code>下载时需要添加<code>--no-check-certificate</code>,否则会<br><code>ERROR: cannot verify github.com&#39;s certificate, issued by ‘CN=GoAgent,OU=GoAgent,O=GoAgent,L=Cernet,ST=Internet,C=CN’:
  Unable to locally verify the issuer&#39;s authority.</code>   </p>
<p>  之后找到解决办法再来更新</p>
<p>其他app也是可以,像迅雷,百度云,spotify这些,很省流量啊</p>
]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ipv6&quot;&gt;&lt;a href=&quot;#ipv6&quot; class=&quot;headerlink&quot; title=&quot;ipv6&quot;&gt;&lt;/a&gt;ipv6&lt;/h2&gt;&lt;p&gt;If you ask Google “What is ipv6 ?”, the first entry it will di
    
    </summary>
    
      <category term="Mac配置" scheme="http://wongchen.github.io/categories/Mac%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="IPv6" scheme="http://wongchen.github.io/tags/IPv6/"/>
    
      <category term="GAE" scheme="http://wongchen.github.io/tags/GAE/"/>
    
  </entry>
  
  <entry>
    <title>我的Vim配置</title>
    <link href="http://wongchen.github.io/2016/11/13/%E6%88%91%E7%9A%84MacVim%E9%85%8D%E7%BD%AE/"/>
    <id>http://wongchen.github.io/2016/11/13/我的MacVim配置/</id>
    <published>2016-11-13T05:14:35.000Z</published>
    <updated>2017-08-09T11:50:21.000Z</updated>
    
    <content type="html"><![CDATA[<p>网上关于Vim配置的讲很多，一键配置也很多。但是我们使用Vim不是因为它的插件实现的功能，自动补全，提示有多厉害，而是它自身的逻辑，自身的快速定位，格式化代码。</p>
<p>所以自己使用方便，好用的配置才是最好的！</p>
<p>我起初就是写<code>python</code>，所以主要配置围绕<code>python</code>。首先，在<code>~</code>目录新建<code>.vimrc</code>文件，添加一些配置：</p>
<p><a href="https://github.com/WongChen/.vim/blob/master/.vimrc" target="_blank" rel="external">vimrc</a>文件在这.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div></pre></td><td class="code"><pre><div class="line">&quot;去掉vi的一致性</div><div class="line">set nocompatible</div><div class="line">&quot;文件类型</div><div class="line">filetype on</div><div class="line">自动补全</div><div class="line">set autoindent</div><div class="line">智能补全</div><div class="line">set smartindent</div><div class="line">&quot;显示行号</div><div class="line">set nu!</div><div class="line">&quot;高亮搜索</div><div class="line">set hlsearch</div><div class="line">tab size</div><div class="line">set tabstop=4</div><div class="line">&quot;不折叠</div><div class="line">set unwrap</div><div class="line">&quot;指示当前行</div><div class="line">set cursorline</div><div class="line">&quot;指示当前列</div><div class="line">set cursorcolumn</div><div class="line">&quot;语法</div><div class="line">syntax enable</div><div class="line">&quot;根据文件类型缩进</div><div class="line">filetype indent on</div><div class="line"></div><div class="line">syntax on</div><div class="line">&quot;python 缩进4</div><div class="line">au FileType python set cindent shiftwidth=4</div><div class="line"></div><div class="line">&quot; 绑定jk为ESC按键,操作更方便</div><div class="line">inoremap jk &lt;ESC&gt;</div><div class="line"></div><div class="line">&quot; 设置 leader key 为空格键</div><div class="line">let mapleader = &quot;\&lt;Space&gt;&quot;</div><div class="line"></div><div class="line">&quot;设置在插入模式下, xz为下行输入, zx为上行输入</div><div class="line">imap xz &lt;ESC&gt;o</div><div class="line">imap zx &lt;Up&gt;&lt;ESC&gt;o</div><div class="line"></div><div class="line">&quot;结合leader key设置  空格加w 保存, 空格加zz 保存退出,也是为了快捷操作&quot;</div><div class="line">nnoremap &lt;Leader&gt;zz :wq&lt;CR&gt;</div><div class="line">nnoremap &lt;Leader&gt;w :w&lt;CR&gt;</div></pre></td></tr></table></figure>
<p>之后安装插件:</p>
<h2 id="vundle插件管理工具"><a href="#vundle插件管理工具" class="headerlink" title="vundle插件管理工具"></a>vundle插件管理工具</h2><ul>
<li>安装</li>
</ul>
<p><code>git clone https://github.com/gmarik/vundle.git ~/.vim/bundle/vundle</code></p>
<ul>
<li>配置</li>
</ul>
<p>在<code>.vimrc</code>中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">set rtp+=~/.vim/bundle/vundle/</div><div class="line">call vundle#rc()</div></pre></td></tr></table></figure>
<ul>
<li>插件安装</li>
</ul>
<p>目前我用的插件,之后再更新.</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">&quot;目前我使用的插件</div><div class="line"></div><div class="line">Bundle &apos;gmarik/vundle&apos;</div><div class="line"></div><div class="line">Bundle &apos;davidhalter/jedi&apos;</div><div class="line"></div><div class="line">Bundle &apos;Valloric/YouCompleteMe&apos;</div><div class="line"></div><div class="line">Bundle &apos;jiangmiao/auto-pairs&apos;</div><div class="line"></div><div class="line">Bundle &apos;scrooloose/nerdcommenter&apos;</div></pre></td></tr></table></figure>
<p>安装插件,只需在任一vim窗口<code>normal</code>模式下执行<code>BundleInstall</code>即可.</p>
<h2 id="jedi"><a href="#jedi" class="headerlink" title="jedi"></a>jedi</h2><p>Python补全强力插件.</p>
<h3 id="YouCompleteMe"><a href="#YouCompleteMe" class="headerlink" title="YouCompleteMe"></a>YouCompleteMe</h3><h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><blockquote>
<p><a href="http://valloric.github.io/YouCompleteMe/#intro" target="_blank" rel="external">YouCompleteMe</a> is a fast, as-you-type, fuzzy-search code completion engine for Vim.</p>
</blockquote>
<p>特点:</p>
<ul>
<li>识别every language</li>
<li>支持C-family languages(C/C++/Objective-C/Objective-C++)</li>
<li>对于Python2/3附带Jedi-based补全(尴尬,另外的jedi卸载了也没关系),使用jediHttp wrapper</li>
<li>an OmniSharp-based completion engine for C#(不懂C#)</li>
<li>a Tern-based completion engine for JavaScript</li>
<li>…</li>
</ul>
<p>此外还有<a href="a Tern-based completion engine for JavaScript">semantic IDE-like features</a>,像goto declarations, definitions, usages, etc这种,根据语意重命名变量(rename variables)等等,使用体验试试吧</p>
<h4 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h4><ul>
<li>使用mvim(Vim binary that is inside the MacVim.app package )更好体验,将vim链接到mvim</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">ln -s /usr/local/bin/mvim vim</div></pre></td></tr></table></figure>
<ul>
<li>vundle cloneYCM后,到YCM目录编译,需要用到<a href="https://cmake.org/download/" target="_blank" rel="external">Cmake</a></li>
<li>编译</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">cd ~/.vim/bundle/YouCompleteMe</div><div class="line">./install.py --[xxx]</div></pre></td></tr></table></figure>
<p>可选参数有:</p>
<ul>
<li>–clang-completer,添加C-family支持</li>
<li>–all, everything</li>
</ul>
<h3 id="auto-pairs"><a href="#auto-pairs" class="headerlink" title="auto-pairs"></a>auto-pairs</h3><p>添加引号,括号配对补全,不多说了.</p>
<h2 id="nerdcommenter"><a href="#nerdcommenter" class="headerlink" title="nerdcommenter"></a>nerdcommenter</h2><p>添加/解除注释,支持多种语言,默认操作为:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;leader&gt;cc   加注释</div><div class="line">&lt;leader&gt;cu   解开注释</div></pre></td></tr></table></figure>
<h2 id="vim学习"><a href="#vim学习" class="headerlink" title="vim学习"></a>vim学习</h2><ul>
<li><code>vimtutor</code>是最基础的老师了.</li>
<li>在推荐一个<a href="https://getpocket.com/a/read/43816131" target="_blank" rel="external">vim 学习的链接</a>,看完这个应该能学到好多</li>
<li>话说新MacBook Pro with TouchBar取消了<code>esc</code>键后,vim使用便比较尴尬</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">inoremap jk &lt;ESC&gt;</div></pre></td></tr></table></figure>
<p>环境搭建好之后,强迫自己多使用学习到的vim高端操作,逐渐熟悉,尤其是在远程CLI环境中,vim很有用,慢慢你会熟悉掌握并爱上vim.</p>
<p>映射到自己喜欢的按键吧.<br>等等.</p>
]]></content>
    
    <summary type="html">
    
      &lt;p&gt;网上关于Vim配置的讲很多，一键配置也很多。但是我们使用Vim不是因为它的插件实现的功能，自动补全，提示有多厉害，而是它自身的逻辑，自身的快速定位，格式化代码。&lt;/p&gt;
&lt;p&gt;所以自己使用方便，好用的配置才是最好的！&lt;/p&gt;
&lt;p&gt;我起初就是写&lt;code&gt;python&lt;/c
    
    </summary>
    
      <category term="Mac配置" scheme="http://wongchen.github.io/categories/Mac%E9%85%8D%E7%BD%AE/"/>
    
    
      <category term="mac" scheme="http://wongchen.github.io/tags/mac/"/>
    
      <category term="vim" scheme="http://wongchen.github.io/tags/vim/"/>
    
  </entry>
  
</feed>
